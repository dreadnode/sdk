// Generated by Dreadnode SDK - Cloudflare Worker
// Serves: {% for name in component_names %}{{ name }}{% if not loop.last %}, {% endif %}{% endfor %}

// Do not edit manually - regenerate using CloudflareWorkersDeployer

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);

    // CORS preflight handling
    if (request.method === "OPTIONS") {
      return new Response(null, {
        headers: {
          "Access-Control-Allow-Origin": "{{ cors_origins }}",
          "Access-Control-Allow-Methods": "POST, GET, OPTIONS",
          "Access-Control-Allow-Headers": "Content-Type, Authorization, X-API-Key",
          "Access-Control-Max-Age": "86400",
        },
      });
    }

    // Health check endpoint
    if (url.pathname === "/health" && request.method === "GET") {
      return jsonResponse({
        status: "ok",
        components: {{ component_names | tojson }},
        endpoints: {{ endpoint_paths | tojson }},
        timestamp: new Date().toISOString(),
      });
    }

    // List endpoints
    if (url.pathname === "/" && request.method === "GET") {
      return jsonResponse({
        endpoints: [
{% for endpoint in endpoints %}
          {
            path: "{{ endpoint.path }}",
            method: "{{ endpoint.method }}",
            component: "{{ endpoint.name }}",
            type: "{{ endpoint.component_type.value }}",
          },
{% endfor %}
        ],
      });
    }

{% for endpoint in endpoints %}
    // {{ endpoint.component_type.value | title }}: {{ endpoint.name }} -> {{ endpoint.path }}
    if (url.pathname === "{{ endpoint.path }}" && request.method === "{{ endpoint.method }}") {
{% if endpoint.auth_mode.value == "api_key" %}
      const authError = validateApiKey(request, env);
      if (authError) return authError;
{% elif endpoint.auth_mode.value == "jwt" %}
      const authError = validateJwt(request);
      if (authError) return authError;
{% elif endpoint.auth_mode.value == "cloudflare_access" %}
      const authError = validateCloudflareAccess(request);
      if (authError) return authError;
{% endif %}

      return await handleRequest(request, env, {
        componentName: "{{ endpoint.name }}",
        componentType: "{{ endpoint.component_type.value }}",
        endpoint: "{{ endpoint.path }}",
      });
    }

{% endfor %}
    // 404 for unmatched routes
    return jsonResponse(
      { error: "Not Found", message: `No handler for ${request.method} ${url.pathname}` },
      404
    );
  },

{% if queues %}
  async queue(batch, env) {
    const results = [];

    for (const message of batch.messages) {
      try {
        const body = message.body;
        const componentName = body.component || "{{ queues[0].component_name }}";
        const componentType = body.type || "{{ queues[0].component_type.value }}";

        const response = await callBackend(env, {
          componentName,
          componentType,
          payload: body,
          messageId: message.id,
        });

        if (!response.ok) {
          throw new Error(`Backend error: ${response.status}`);
        }

        results.push({ messageId: message.id, success: true });
        message.ack();

      } catch (error) {
        console.error(`Error processing message ${message.id}:`, error);
        message.retry();
      }
    }

    return results;
  },
{% endif %}
};

// Utility functions

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "{{ cors_origins }}",
    },
  });
}

function validateApiKey(request, env) {
  const apiKey = request.headers.get("X-API-Key") ||
                 request.headers.get("Authorization")?.replace("Bearer ", "");

  if (!apiKey || apiKey !== env.AGENT_API_KEY) {
    return jsonResponse(
      { error: "Unauthorized", message: "Invalid or missing API key" },
      401
    );
  }
  return null;
}

function validateJwt(request) {
  const authHeader = request.headers.get("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return jsonResponse(
      { error: "Unauthorized", message: "Missing Bearer token" },
      401
    );
  }
  // JWT validation is done by the backend
  return null;
}

function validateCloudflareAccess(request) {
  const cfAccessJwt = request.headers.get("Cf-Access-Jwt-Assertion");
  if (!cfAccessJwt) {
    return jsonResponse(
      { error: "Unauthorized", message: "Missing Cloudflare Access token" },
      401
    );
  }
  return null;
}

async function handleRequest(request, env, context) {
  try {
    // Parse request body
    let body;
    try {
      body = await request.json();
    } catch (e) {
      return jsonResponse(
        { error: "Bad Request", message: "Invalid JSON body" },
        400
      );
    }

    // Validate based on component type
    if (context.componentType === "agent") {
      if (!body.goal || typeof body.goal !== "string") {
        return jsonResponse(
          { error: "Bad Request", message: "Missing or invalid 'goal' field for agent" },
          400
        );
      }
    } else if (context.componentType === "evaluation") {
      if (!body.dataset && !body.inputs) {
        return jsonResponse(
          { error: "Bad Request", message: "Missing 'dataset' or 'inputs' for evaluation" },
          400
        );
      }
    } else if (context.componentType === "study") {
      if (!body.parameters) {
        return jsonResponse(
          { error: "Bad Request", message: "Missing 'parameters' for study" },
          400
        );
      }
    }

    return await callBackend(env, {
      componentName: context.componentName,
      componentType: context.componentType,
      payload: body,
    });

  } catch (error) {
    console.error("Error in handleRequest:", error);
    return jsonResponse(
      { error: "Internal Server Error", message: error.message || "An unexpected error occurred" },
      500
    );
  }
}

async function callBackend(env, { componentName, componentType, payload, messageId }) {
  const backendUrl = env.BACKEND_URL;
  if (!backendUrl) {
    return jsonResponse(
      { error: "Configuration Error", message: "BACKEND_URL not configured" },
      500
    );
  }

  const headers = {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${env.BACKEND_API_KEY}`,
    "X-Component-Name": componentName,
    "X-Component-Type": componentType,
  };

  if (messageId) {
    headers["X-Queue-Message-Id"] = messageId;
  }

  const response = await fetch(backendUrl, {
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errorText = await response.text();
    let errorJson;
    try {
      errorJson = JSON.parse(errorText);
    } catch {
      errorJson = { error: "Backend Error", message: errorText };
    }
    return jsonResponse(errorJson, response.status);
  }

  const result = await response.json();
  return jsonResponse(result);
}
