---
title: dreadnode.optimization
---

{/*
::: dreadnode.optimization.study
::: dreadnode.optimization.trial
::: dreadnode.optimization.events
::: dreadnode.optimization.search
*/}

Direction
---------

```python
Direction = Literal['maximize', 'minimize']
```

The direction of optimization for the objective score.

Study
-----

### concurrency

```python
concurrency: int = Config(default=1, ge=1)
```

The maximum number of trials to evaluate in parallel.

### constraints

```python
constraints: list[Scorer[CandidateT]] | None = Config(default=None)
```

A list of Scorer-like constraints to apply to candidates. If any constraint scores to a falsy value, the candidate is pruned.

### dataset

```python
dataset: InputDataset[Any] | list[AnyDict] | FilePath | None = Config(default=None, expose_as=FilePath | None)
```

The dataset to use for the evaluation. Can be a list of inputs or a file path to load inputs from.
If `None`, an empty dataset with a single empty input will be used.

### description

```python
description: str = Config(default='')
```

A brief description of the study's purpose.

### direction

```python
direction: Direction = Config(default='maximize')
```

The direction of optimization for the objective score.

### max\_steps

```python
max_steps: int = Config(default=100, ge=1)
```

The maximum number of optimization steps to run.

### name

```python
name: str | None = Config(default=None)
```

The name of the study - otherwise derived from the task.

### objective

```python
objective: ScorerLike[Any] | str = Config(default_factory=list)
```

The objective to optimize. Can be a scorer instance, a scorer-like callable, or a string name of scorer already on the task.

### objective\_fn

```python
objective_fn: Callable[[EvalResult], float] | None = Config(default=None)
```

An optional function to compute a score from a full EvalResult, overriding the default averaging behavior.

### patience

```python
patience: int | None = Config(default=None, ge=1)
```

The number of steps to wait for an improvement before stopping. If None, this is disabled.

### strategy

```python
strategy: Annotated[Search[CandidateT], Config()]
```

The search strategy to use for suggesting new trials.

### tags

```python
tags: list[str] = Config(default_factory=lambda: ['study'])
```

A list of tags associated with the study.

### target\_score

```python
target_score: float | None = Config(default=None)
```

A target score to achieve. The study will stop if a trial meets or exceeds this score.

### task\_factory

```python
task_factory: Callable[[CandidateT], Task[..., Any]]
```

A function that accepts a candidate and returns a configured Task ready for evaluation.

### console

```python
console() -> StudyResult[CandidateT]
```

Runs the optimization study with a live progress dashboard in the console.

<Accordion title="Source code in dreadnode/optimization/study.py" icon="code">
```python
async def console(self) -> StudyResult[CandidateT]:
    """Runs the optimization study with a live progress dashboard in the console."""
    from dreadnode.optimization.console import StudyConsoleAdapter

    adapter = StudyConsoleAdapter(self)
    return await adapter.run()
```


</Accordion>

### run

```python
run() -> StudyResult[CandidateT]
```

Execute the optimization study to completion and return final results.

This is a convenience method that runs the full optimization process and
returns only the final StudyEnd event containing the complete results.
Use this when you want the final results without processing intermediate events.

For real-time monitoring of the optimization process, use the stream() method instead.

**Raises:**

* `RuntimeError`
  –If the evaluation fails to complete properly.

<Accordion title="Source code in dreadnode/optimization/study.py" icon="code">
```python
async def run(self) -> StudyResult[CandidateT]:
    """
    Execute the optimization study to completion and return final results.

    This is a convenience method that runs the full optimization process and
    returns only the final StudyEnd event containing the complete results.
    Use this when you want the final results without processing intermediate events.

    For real-time monitoring of the optimization process, use the stream() method instead.

    Raises:
        RuntimeError: If the evaluation fails to complete properly.
    """
    async with self.stream() as stream:
        async for event in stream:
            if isinstance(event, StudyEnd):
                return event.result

    raise RuntimeError("Evaluation failed to complete")
```


</Accordion>

### stream

```python
stream() -> t.AsyncIterator[t.AsyncGenerator[StudyEvent[CandidateT], None]]
```

Create an async context manager for the optimization event stream.

This provides a safe way to access the optimization event stream with proper
resource cleanup. The context manager ensures the async generator is properly
closed even if an exception occurs during iteration.

Usage

async with study.stream() as event\_stream:
async for event in event\_stream:
# Process optimization events
pass

**Yields:**

* `AsyncIterator[AsyncGenerator[StudyEvent[CandidateT], None]]`
  –An async generator that produces StudyEvent objects throughout the optimization.

<Accordion title="Source code in dreadnode/optimization/study.py" icon="code">
```python
@contextlib.asynccontextmanager
async def stream(self) -> t.AsyncIterator[t.AsyncGenerator[StudyEvent[CandidateT], None]]:
    """
    Create an async context manager for the optimization event stream.

    This provides a safe way to access the optimization event stream with proper
    resource cleanup. The context manager ensures the async generator is properly
    closed even if an exception occurs during iteration.

    Usage:
        async with study.stream() as event_stream:
            async for event in event_stream:
                # Process optimization events
                pass

    Yields:
        An async generator that produces StudyEvent objects throughout the optimization.
    """
    async with contextlib.aclosing(self._stream_traced()) as gen:
        yield gen
```


</Accordion>
Trial
-----

Represents a single, evaluated point in the search space.

### candidate

```python
candidate: CandidateT
```

The candidate configuration being assessed.

### error

```python
error: str | None = None
```

Any error which occurred while processing this trial.

### eval\_result

```python
eval_result: EvalResult | None = None
```

Complete evaluation result if the candidate was assessable by the evaluation engine.

### id

```python
id: UUID = Field(default_factory=uuid4)
```

Unique identifier for the trial.

### output

```python
output: Any | None
```

Get the output of the trial.

### parent\_id

```python
parent_id: UUID | None = None
```

The id of the parent trial, used to reconstruct the search graph.

### pruning\_reason

```python
pruning_reason: str | None = None
```

Reason for pruning this trial, if applicable.

### score

```python
score: float = -float('inf')
```

Fitness score of this candidate. Higher is better.

### status

```python
status: TrialStatus = 'pending'
```

Current status of the trial.

### step

```python
step: int = 0
```

The optimization step which produced this trial.

TrialCollector
--------------

Collect a list of relevant trials based on the current trial.

TrialSampler
------------

Sample from a list of trials.

Distribution
------------

```python
Distribution()
```

Base class for all search space distributions.

Search
------

Abstract base class for all optimization search strategies.

### observe

```python
observe(trials: Trials[CandidateT]) -> None
```

Informs the strategy of the results of recent trials.

<Accordion title="Source code in dreadnode/optimization/search/base.py" icon="code">
```python
@abstractmethod
async def observe(self, trials: Trials[CandidateT]) -> None:
    """Informs the strategy of the results of recent trials."""
```


</Accordion>

### reset

```python
reset() -> None
```

Resets the search strategy to its initial state.

<Accordion title="Source code in dreadnode/optimization/search/base.py" icon="code">
```python
@abstractmethod
def reset(self) -> None:
    """Resets the search strategy to its initial state."""
```


</Accordion>

### suggest

```python
suggest(step: int) -> Trials[CandidateT]
```

Suggests the next batch of candidates.

<Accordion title="Source code in dreadnode/optimization/search/base.py" icon="code">
```python
@abstractmethod
async def suggest(self, step: int) -> Trials[CandidateT]:
    """Suggests the next batch of candidates."""
```


</Accordion>