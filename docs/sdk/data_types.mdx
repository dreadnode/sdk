---
title: dreadnode.data_types
---

{/*
::: dreadnode.data_types
*/}

Audio
-----

```python
Audio(
    data: AudioDataType,
    sample_rate: int | None = None,
    caption: str | None = None,
    format: str | None = None,
)
```

Audio media type for Dreadnode logging.

Supports:
- Local file paths (str or Path)
- Numpy arrays with sample rate
- Raw bytes

Initialize an Audio object.

**Parameters:**

* **`data`**
  (`AudioDataType`)
  –The audio data, which can be:
  - A path to a local audio file (str or Path)
  - A numpy array (requires sample\_rate)
  - Raw bytes
* **`sample_rate`**
  (`int | None`, default:
  `None`
  )
  –Required when using numpy arrays
* **`caption`**
  (`str | None`, default:
  `None`
  )
  –Optional caption for the audio
* **`format`**
  (`str | None`, default:
  `None`
  )
  –Optional format to use (default is wav for numpy arrays)

<Accordion title="Source code in dreadnode/data_types/audio.py" icon="code">
```python
def __init__(
    self,
    data: AudioDataType,
    sample_rate: int | None = None,
    caption: str | None = None,
    format: str | None = None,
):
    """
    Initialize an Audio object.

    Args:
        data: The audio data, which can be:
            - A path to a local audio file (str or Path)
            - A numpy array (requires sample_rate)
            - Raw bytes
        sample_rate: Required when using numpy arrays
        caption: Optional caption for the audio
        format: Optional format to use (default is wav for numpy arrays)
    """
    with catch_import_error("dreadnode[multimodal]"):
        import soundfile  # type: ignore[import-not-found] # noqa: F401

    self._data = data
    self._sample_rate = sample_rate
    self._caption = caption
    self._format = format
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[t.Any, dict[str, t.Any]]
```

Serialize the audio data to bytes and return with metadata.
Returns:
A tuple of (audio\_bytes, metadata\_dict)

<Accordion title="Source code in dreadnode/data_types/audio.py" icon="code">
```python
def to_serializable(self) -> tuple[t.Any, dict[str, t.Any]]:
    """
    Serialize the audio data to bytes and return with metadata.
    Returns:
        A tuple of (audio_bytes, metadata_dict)
    """
    audio_bytes, format_name, sample_rate, duration = self._process_audio_data()
    metadata = self._generate_metadata(format_name, sample_rate, duration)
    return audio_bytes, metadata
```


</Accordion>

Code
----

```python
Code(text: str, language: str = '')
```

Hint type for code-formatted text.

This is a subclass of Text with format set to "code".

Example

```python
log_output("code_snippet", Code("print('Hello, World!')", language="python"))
```


<Accordion title="Source code in dreadnode/data_types/text.py" icon="code">
```python
def __init__(self, text: str, language: str = ""):
    super().__init__(text, format="code")
    self._language = language
```


</Accordion>

Image
-----

```python
Image(
    data: ImageDataOrPathType,
    mode: str | None = None,
    caption: str | None = None,
    format: str | None = None,
)
```

Image media type for Dreadnode logging.

This class maintains a high-fidelity float32 numpy array as the canonical
representation, ensuring no precision loss during use in transforms, scorers,
and optimization routines.

Initialize an Image object.

**Parameters:**

* **`data`**
  (`ImageDataOrPathType`)
  –The image data, which can be:
  - A file path (str or Path)
  - A base64-encoded string (starting with "data:image/")
  - Raw bytes of an image file
  - A numpy array (HWC or HW format)
  - A Pillow Image object
* **`mode`**
  (`str | None`, default:
  `None`
  )
  –Optional mode for the image (RGB, L, etc.)
* **`caption`**
  (`str | None`, default:
  `None`
  )
  –Optional caption for the image
* **`format`**
  (`str | None`, default:
  `None`
  )
  –Optional format to use when saving (png, jpg, etc.)

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def __init__(
    self,
    data: ImageDataOrPathType,
    mode: str | None = None,
    caption: str | None = None,
    format: str | None = None,
):
    """
    Initialize an Image object.

    Args:
        data: The image data, which can be:
            - A file path (str or Path)
            - A base64-encoded string (starting with "data:image/")
            - Raw bytes of an image file
            - A numpy array (HWC or HW format)
            - A Pillow Image object
        mode: Optional mode for the image (RGB, L, etc.)
        caption: Optional caption for the image
        format: Optional format to use when saving (png, jpg, etc.)
    """
    with catch_import_error("dreadnode[multimodal]"):
        import PIL.Image  # type: ignore[import-not-found]  # noqa: F401

    self._caption = caption

    self._source_metadata = self._extract_source_metadata(data, format)
    self._format = self._source_metadata.get("format", "png")
    self._canonical_array, self._mode = self._load_and_convert(data, mode)

    # Caches for conversions
    self._pil_cache: PILImage | None = None
    self._base64_cache: str | None = None
```


</Accordion>

### canonical\_array

```python
canonical_array: ndarray[Any, dtype[float32]]
```

Get the canonical high-fidelity representation.

**Returns:**

* `ndarray[Any, dtype[float32]]`
  –float32 numpy array in [0,1] range, HWC format

### mode

```python
mode: str
```

Get the image mode (L, RGB, RGBA, etc.).

### shape

```python
shape: tuple[int, ...]
```

Get the shape of the canonical array.

### show

```python
show() -> None
```

Displays the image using the default image viewer.

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def show(self) -> None:
    """Displays the image using the default image viewer."""
    self.to_pil().show()
```


</Accordion>

### to\_base64

```python
to_base64() -> str
```

Returns the image as a base64 encoded string.

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def to_base64(self) -> str:
    """Returns the image as a base64 encoded string."""
    if self._base64_cache is None:
        buffer = io.BytesIO()
        self.to_pil().save(buffer, format=self._format.upper())
        self._base64_cache = base64.b64encode(buffer.getvalue()).decode("utf-8")

    return self._base64_cache
```


</Accordion>

### to\_numpy

```python
to_numpy(
    dtype: Any = np.float32,
) -> np.ndarray[t.Any, t.Any]
```

Returns the image as a NumPy array with specified dtype.

**Parameters:**

* **`dtype`**
  (`Any`, default:
  `float32`
  )
  –Target dtype. Common options:
  - np.float32/np.float64: Values in [0.0, 1.0] (recommended)
  - np.uint8: Values in [0, 255]

**Returns:**

* `ndarray[Any, Any]`
  –NumPy array in HWC format (or HW for grayscale)

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def to_numpy(self, dtype: t.Any = np.float32) -> "np.ndarray[t.Any, t.Any]":
    """
    Returns the image as a NumPy array with specified dtype.

    Args:
        dtype: Target dtype. Common options:
            - np.float32/np.float64: Values in [0.0, 1.0] (recommended)
            - np.uint8: Values in [0, 255]

    Returns:
        NumPy array in HWC format (or HW for grayscale)
    """
    arr = self._canonical_array.copy()

    if np.issubdtype(dtype, np.integer):  # noqa: SIM108
        # Convert to integer range [0, 255]
        arr = (arr * 255.0).astype(dtype)
    else:
        # Keep float range [0, 1]
        arr = arr.astype(dtype)

    return arr
```


</Accordion>

### to\_pil

```python
to_pil() -> PILImage
```

Returns the image as a Pillow Image object.

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def to_pil(self) -> "PILImage":
    """Returns the image as a Pillow Image object."""
    if self._pil_cache is None:
        # Convert canonical array to PIL
        arr = (self._canonical_array * 255).astype(np.uint8)

        import PIL.Image

        self._pil_cache = PIL.Image.fromarray(arr, mode=self._mode)

    return self._pil_cache.copy()  # Return copy to prevent mutation
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[bytes, dict[str, t.Any]]
```

Convert the image to bytes and return with metadata.

**Returns:**

* `tuple[bytes, dict[str, Any]]`
  –Tuple of (image\_bytes, metadata\_dict)

<Accordion title="Source code in dreadnode/data_types/image.py" icon="code">
```python
def to_serializable(self) -> tuple[bytes, dict[str, t.Any]]:
    """
    Convert the image to bytes and return with metadata.

    Returns:
        Tuple of (image_bytes, metadata_dict)
    """
    buffer = io.BytesIO()
    pil_img = self.to_pil()
    pil_img.save(buffer, format=self._format.upper())
    image_bytes = buffer.getvalue()

    # Rich metadata including source information
    metadata = {
        "extension": self._format.lower(),
        "x-python-datatype": "dreadnode.Image.bytes",
        "mode": self.mode,
        "width": self.shape[1] if len(self.shape) >= 2 else self.shape[0],
        "height": self.shape[0],
    }

    # Add source metadata
    metadata.update(self._source_metadata)

    if len(self.shape) == 3:
        metadata["channels"] = self.shape[2]
    else:
        metadata["channels"] = 1

    if self._caption:
        metadata["caption"] = self._caption

    return image_bytes, metadata
```


</Accordion>

Markdown
--------

```python
Markdown(text: str)
```

Hint type for markdown-formatted text.

This is a subclass of Text with format set to "markdown".

Example

```python
log_output("report", Markdown("..."))
```


<Accordion title="Source code in dreadnode/data_types/text.py" icon="code">
```python
def __init__(self, text: str):
    super().__init__(text, format="markdown")
```


</Accordion>

Object3D
--------

```python
Object3D(
    data: Object3DDataType,
    caption: str | None = None,
    format: str | None = None,
)
```

3D object media type for Dreadnode logging.

Supports:
- Local file paths to 3D models (.obj, .glb, .gltf, etc.)
- Raw bytes with metadata

Initialize a 3D Object.

**Parameters:**

* **`data`**
  (`Object3DDataType`)
  –The 3D object data, which can be:
  - A path to a local 3D model file (str or Path)
  - Raw bytes of a 3D model file
* **`caption`**
  (`str | None`, default:
  `None`
  )
  –Optional caption for the 3D object
* **`format`**
  (`str | None`, default:
  `None`
  )
  –Optional format override (obj, glb, etc.)

<Accordion title="Source code in dreadnode/data_types/object_3d.py" icon="code">
```python
def __init__(
    self,
    data: Object3DDataType,
    caption: str | None = None,
    format: str | None = None,
):
    """
    Initialize a 3D Object.

    Args:
        data: The 3D object data, which can be:
            - A path to a local 3D model file (str or Path)
            - Raw bytes of a 3D model file
        caption: Optional caption for the 3D object
        format: Optional format override (obj, glb, etc.)
    """
    self._data = data
    self._caption = caption
    self._format = format
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[bytes, dict[str, t.Any]]
```

Convert the 3D object to bytes and return with metadata.

**Returns:**

* `tuple[bytes, dict[str, Any]]`
  –A tuple of (object\_bytes, metadata\_dict)

<Accordion title="Source code in dreadnode/data_types/object_3d.py" icon="code">
```python
def to_serializable(self) -> tuple[bytes, dict[str, t.Any]]:
    """
    Convert the 3D object to bytes and return with metadata.

    Returns:
        A tuple of (object_bytes, metadata_dict)
    """
    if isinstance(self._data, str | Path) and Path(self._data).exists():
        return self._process_file_path()
    if isinstance(self._data, bytes):
        format_name = self._format or "glb"
        return self._data, self._generate_metadata(format_name)
    raise TypeError(f"Unsupported 3D object data type: {type(self._data)}")
```


</Accordion>

Table
-----

```python
Table(
    data: TableDataType,
    caption: str | None = None,
    format: str | None = None,
    *,
    index: bool = False,
)
```

Table data type for Dreadnode logging.

Supports:
- Pandas DataFrames
- CSV/Parquet/JSON files
- Dict or list data structures
- NumPy arrays

Initialize a Table object.

**Parameters:**

* **`data`**
  (`TableDataType`)
  –The table data, which can be:
  - A pandas DataFrame
  - A path to a CSV/JSON/Parquet file
  - A dict or list of dicts
  - A NumPy array
* **`caption`**
  (`str | None`, default:
  `None`
  )
  –Optional caption for the table
* **`format`**
  (`str | None`, default:
  `None`
  )
  –Optional format to use when saving (csv, parquet, json)
* **`index`**
  (`bool`, default:
  `False`
  )
  –Include index in the output

<Accordion title="Source code in dreadnode/data_types/table.py" icon="code">
```python
def __init__(
    self,
    data: TableDataType,
    caption: str | None = None,
    format: str | None = None,
    *,
    index: bool = False,
):
    """
    Initialize a Table object.

    Args:
        data: The table data, which can be:
            - A pandas DataFrame
            - A path to a CSV/JSON/Parquet file
            - A dict or list of dicts
            - A NumPy array
        caption: Optional caption for the table
        format: Optional format to use when saving (csv, parquet, json)
        index: Include index in the output
    """
    self._data = data
    self._caption = caption
    self._format = format or "csv"  # Default to CSV
    if self._format not in self.SUPPORTED_FORMATS:
        raise ValueError(
            f"Unsupported format: {self._format}. "
            f"Supported formats are: {', '.join(self.SUPPORTED_FORMATS)}"
        )
    self._index = index
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[bytes, dict[str, t.Any]]
```

Convert the table to bytes and return with metadata.

**Returns:**

* `tuple[bytes, dict[str, Any]]`
  –A tuple of (table\_bytes, metadata\_dict)

<Accordion title="Source code in dreadnode/data_types/table.py" icon="code">
```python
def to_serializable(self) -> tuple[bytes, dict[str, t.Any]]:
    """
    Convert the table to bytes and return with metadata.

    Returns:
        A tuple of (table_bytes, metadata_dict)
    """
    data_frame = self._to_dataframe()

    table_bytes = self._dataframe_to_bytes(data_frame)
    metadata = self._generate_metadata(data_frame)

    return table_bytes, metadata
```


</Accordion>

Text
----

```python
Text(text: str, format: str)
```

Text data type for Dreadnode logging.

Initialize a Text object.

**Parameters:**

* **`text`**
  (`str`)
  –The text content to log
* **`format`**
  (`str`)
  –The format hint of the text

<Accordion title="Source code in dreadnode/data_types/text.py" icon="code">
```python
def __init__(self, text: str, format: str):
    """
    Initialize a Text object.

    Args:
        text: The text content to log
        format: The format hint of the text
    """
    self._text = text
    self._format = format
```


</Accordion>

Video
-----

```python
Video(
    data: VideoDataType,
    fps: float | None = None,
    caption: str | None = None,
    format: str | None = None,
    width: int | None = None,
    height: int | None = None,
)
```

Video media type for Dreadnode logging.

Supports:
- Local file paths (str or Path)
- Numpy array sequences with frame rate
- Raw bytes with metadata
- MoviePy VideoClip objects (if installed)

Initialize a Video object.

**Parameters:**

* **`data`**
  (`VideoDataType`)
  –The video data, which can be:
  - A path to a local video file (str or Path)
  - A numpy array of frames (requires fps)
  - A list of numpy arrays for individual frames (requires fps)
  - Raw bytes
  - A MoviePy VideoClip object (if MoviePy is installed)
* **`fps`**
  (`float | None`, default:
  `None`
  )
  –Frames per second, required for numpy array input
  (ignored if data is a file path or raw bytes)
* **`caption`**
  (`str | None`, default:
  `None`
  )
  –Optional caption for the video
* **`format`**
  (`str | None`, default:
  `None`
  )
  –Optional format override (mp4, avi, etc.)
* **`width`**
  (`int | None`, default:
  `None`
  )
  –Optional width in pixels
* **`height`**
  (`int | None`, default:
  `None`
  )
  –Optional height in pixels

<Accordion title="Source code in dreadnode/data_types/video.py" icon="code">
```python
def __init__(
    self,
    data: VideoDataType,
    fps: float | None = None,
    caption: str | None = None,
    format: str | None = None,
    width: int | None = None,
    height: int | None = None,
):
    """
    Initialize a Video object.

    Args:
        data: The video data, which can be:
            - A path to a local video file (str or Path)
            - A numpy array of frames (requires fps)
            - A list of numpy arrays for individual frames (requires fps)
            - Raw bytes
            - A MoviePy VideoClip object (if MoviePy is installed)
        fps: Frames per second, required for numpy array input
             (ignored if data is a file path or raw bytes)
        caption: Optional caption for the video
        format: Optional format override (mp4, avi, etc.)
        width: Optional width in pixels
        height: Optional height in pixels
    """
    self._data = data
    self._fps = fps
    self._caption = caption
    self._format = format or "mp4"
    self._width = width
    self._height = height
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[bytes, dict[str, t.Any]]
```

Convert the video to bytes and return with metadata.

**Returns:**

* `tuple[bytes, dict[str, Any]]`
  –A tuple of (video\_bytes, metadata\_dict)

<Accordion title="Source code in dreadnode/data_types/video.py" icon="code">
```python
def to_serializable(self) -> tuple[bytes, dict[str, t.Any]]:
    """
    Convert the video to bytes and return with metadata.

    Returns:
        A tuple of (video_bytes, metadata_dict)
    """

    try:
        from moviepy.video.VideoClip import VideoClip  # type: ignore[import-not-found]
    except ImportError:
        VideoClip = None  # noqa: N806

    if isinstance(self._data, str | Path) and Path(self._data).exists():
        return self._process_file_path()
    if isinstance(self._data, bytes):
        return self._process_bytes()
    if isinstance(self._data, np.ndarray | list):
        return self._process_numpy_array()
    if VideoClip is not None and isinstance(self._data, VideoClip):
        return self._process_moviepy_clip()
    if VideoClip is None and hasattr(self._data, "write_videofile"):
        raise ImportError(
            "MoviePy VideoClip detected, but MoviePy is not installed. "
            "Install with: pip install dreadnode[multimodal]"
        )
    raise TypeError(f"Unsupported video data type: {type(self._data)}")
```


</Accordion>

WithMeta
--------

```python
WithMeta(obj: Any, metadata: dict[str, Any])
```

Helper data type to add additional metadata to the schema for logged data.

Example

```python
log_output("my_data", WithMeta(data, {"format": "custom-data"}))
```

Initialize a data type with associated metadata.

**Parameters:**

* **`metadata`**
  (`dict[str, Any]`)
  –The metadata for this data type

<Accordion title="Source code in dreadnode/data_types/base.py" icon="code">
```python
def __init__(self, obj: t.Any, metadata: dict[str, t.Any]):
    """
    Initialize a data type with associated metadata.

    Args:
        metadata: The metadata for this data type
    """
    self._obj = obj
    self._metadata = metadata
```


</Accordion>

### to\_serializable

```python
to_serializable() -> tuple[t.Any, dict[str, t.Any]]
```

Convert the media type to a serializable format.

**Returns:**

* `tuple[Any, dict[str, Any]]`
  –Tuple of (data, metadata) where:
  - data: The serialized data
  - metadata: Additional metadata for this data type

<Accordion title="Source code in dreadnode/data_types/base.py" icon="code">
```python
def to_serializable(self) -> tuple[t.Any, dict[str, t.Any]]:
    """
    Convert the media type to a serializable format.

    Returns:
        Tuple of (data, metadata) where:
            - data: The serialized data
            - metadata: Additional metadata for this data type
    """
    return self._obj, self._metadata
```


</Accordion>