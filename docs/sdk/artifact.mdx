---
title: dreadnode.storage
---

{/*
::: dreadnode.storage.merger
::: dreadnode.storage.tree_builder
*/}

Utility for merging artifact tree structures while preserving directory hierarchy.

ArtifactMerger
--------------

```python
ArtifactMerger()
```

Class responsible for merging artifact tree structures.
Handles overlapping directory structures and efficiently combines artifacts.

Example

```python
# Create a merger instance
merger = ArtifactMerger()

# Add multiple artifact trees
merger.add_tree(tree1)  # First tree gets added directly
merger.add_tree(tree2)  # Second tree gets merged if it overlaps

# Get the merged result
merged_trees = merger.get_merged_trees()
```


<Accordion title="Source code in dreadnode/storage/merger.py" icon="code">
```python
def __init__(self) -> None:
    self._path_map: dict[str, DirectoryNode | FileNode] = {}
    # Maps file hashes to all matching files
    self._hash_map: dict[str, list[FileNode]] = {}
    self._merged_trees: list[DirectoryNode] = []
```


</Accordion>

### add\_tree

```python
add_tree(new_tree: DirectoryNode) -> None
```

Add a new artifact tree, merging with existing trees if needed.

This method analyzes the new tree and determines how to integrate it
with existing trees, handling parent/child relationships and overlaps.

**Parameters:**

* **`new_tree`**
  (`DirectoryNode`)
  –New directory tree to add

Example

```python
# Add first tree (e.g., /data/audio/sub1)
merger.add_tree({
    "type": "dir",
    "dir_path": "/data/audio/sub1",
    "hash": "abc123",
    "children": [...]
})

# Add parent directory later (e.g., /data/audio)
# The merger will recognize the relationship and restructure
merger.add_tree({
    "type": "dir",
    "dir_path": "/data/audio",
    "hash": "def456",
    "children": [...]
})
```


<Accordion title="Source code in dreadnode/storage/merger.py" icon="code">
```python
def add_tree(self, new_tree: DirectoryNode) -> None:
    """
    Add a new artifact tree, merging with existing trees if needed.

    This method analyzes the new tree and determines how to integrate it
    with existing trees, handling parent/child relationships and overlaps.

    Args:
        new_tree: New directory tree to add

    Example:
        ~~~python
        # Add first tree (e.g., /data/audio/sub1)
        merger.add_tree({
            "type": "dir",
            "dir_path": "/data/audio/sub1",
            "hash": "abc123",
            "children": [...]
        })

        # Add parent directory later (e.g., /data/audio)
        # The merger will recognize the relationship and restructure
        merger.add_tree({
            "type": "dir",
            "dir_path": "/data/audio",
            "hash": "def456",
            "children": [...]
        })
        ~~~
    """
    # First artifact - just add it
    if not self._merged_trees:
        self._merged_trees = [new_tree]
        self._build_maps(new_tree)
        return

    # Get new tree's path
    new_dir_path = new_tree["dir_path"]

    # Check for direct match with existing trees
    for existing_tree in self._merged_trees:
        if existing_tree["dir_path"] == new_dir_path:
            # Same directory - merge them
            self._merge_directory_nodes(existing_tree, new_tree)
            self._build_maps()  # Rebuild maps
            return

    # Check if new tree is parent of any existing trees
    children_to_remove = []
    for existing_tree in self._merged_trees:
        existing_dir_path = existing_tree["dir_path"]

        # New tree is parent of existing tree
        if existing_dir_path.startswith(new_dir_path + "/"):
            rel_path = existing_dir_path[len(new_dir_path) + 1 :].split("/")
            self._place_tree_at_path(new_tree, existing_tree, rel_path)
            children_to_remove.append(existing_tree)

    # Remove trees that are now incorporated into new tree
    if children_to_remove:
        for child in children_to_remove:
            if child in self._merged_trees:
                self._merged_trees.remove(child)
        self._merged_trees.append(new_tree)
        self._build_maps()  # Rebuild maps
        return

    # Check if new tree is child of an existing tree
    for existing_tree in self._merged_trees:
        existing_dir_path = existing_tree["dir_path"]

        if new_dir_path.startswith(existing_dir_path + "/"):
            rel_path = new_dir_path[len(existing_dir_path) + 1 :].split("/")
            self._place_tree_at_path(existing_tree, new_tree, rel_path)
            self._build_maps()  # Rebuild maps
            return

    # Try to find and handle overlaps
    new_path_map: dict[str, DirectoryNode | FileNode] = {}
    new_hash_map: dict[str, list[FileNode]] = {}
    self._build_path_and_hash_maps(new_tree, new_path_map, new_hash_map)

    # Find common paths between existing and new tree
    path_overlaps = set(self._path_map.keys()) & set(new_path_map.keys())

    if path_overlaps and self._handle_overlaps(path_overlaps, new_path_map):
        # Successfully merged via overlaps
        self._build_maps()  # Rebuild maps
        return

    # If we get here, add new tree as a separate root
    self._merged_trees.append(new_tree)
    self._build_maps()  # Rebuild maps
```


</Accordion>

### get\_merged\_trees

```python
get_merged_trees() -> list[DirectoryNode]
```

Get the current merged trees.

**Returns:**

* `list[DirectoryNode]`
  –List of merged directory trees

Example

```python
# Get the merged trees after adding multiple trees
trees = merger.get_merged_trees()

# Typically there will be a single root tree if all added trees are related
if len(trees) == 1:
    root_tree = trees[0]
    print(f"Root directory: {root_tree['dir_path']}")
```


<Accordion title="Source code in dreadnode/storage/merger.py" icon="code">
```python
def get_merged_trees(self) -> list[DirectoryNode]:
    """
    Get the current merged trees.

    Returns:
        List of merged directory trees

    Example:
        ~~~python
        # Get the merged trees after adding multiple trees
        trees = merger.get_merged_trees()

        # Typically there will be a single root tree if all added trees are related
        if len(trees) == 1:
            root_tree = trees[0]
            print(f"Root directory: {root_tree['dir_path']}")
        ~~~
    """
    return self._merged_trees
```


</Accordion>
Tree structure builder for artifacts with directory hierarchy preservation.
Provides efficient uploads and tree construction for frontend to consume.

ArtifactTreeBuilder
-------------------

```python
ArtifactTreeBuilder(
    storage: ArtifactStorage, prefix_path: str | None = None
)
```

Builds a hierarchical tree structure for artifacts while uploading them to storage.
Preserves directory structure and handles efficient uploads.

### process\_artifact

```python
process_artifact(local_uri: str | Path) -> DirectoryNode
```

Process an artifact (file or directory) and build its tree representation.

**Parameters:**

* **`local_uri`**
  (`str | Path`)
  –Path to the local file or directory

**Returns:**

* `DirectoryNode`
  –Directory tree structure representing the artifact

**Raises:**

* `FileNotFoundError`
  –If the path doesn't exist

<Accordion title="Source code in dreadnode/storage/tree_builder.py" icon="code">
```python
def process_artifact(self, local_uri: str | Path) -> DirectoryNode:
    """
    Process an artifact (file or directory) and build its tree representation.

    Args:
        local_uri: Path to the local file or directory

    Returns:
        Directory tree structure representing the artifact

    Raises:
        FileNotFoundError: If the path doesn't exist
    """
    local_path = Path(local_uri).expanduser().resolve()
    if not local_path.exists():
        raise FileNotFoundError(f"{local_path} does not exist")

    if local_path.is_dir():
        return self._process_directory(local_path)

    return self._process_single_file(local_path)
```


</Accordion>

DirectoryNode
-------------

Represents a directory node in the artifact tree.
Contains metadata about the directory, including its dir\_path, hash, and children nodes.

FileNode
--------

Represents a file node in the artifact tree.
Contains metadata about the file, including its name, uri, size\_bytes, and final\_real\_path.