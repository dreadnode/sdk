---
title: dreadnode.agent
---

{/*
::: dreadnode.agent.agent
::: dreadnode.agent.hooks
::: dreadnode.agent.events
::: dreadnode.agent.reactions
::: dreadnode.agent.result
::: dreadnode.agent.stop
::: dreadnode.agent.thread
*/}

Agent
-----

Agent abstraction for applying tools, event logic, and message state to LLM generation.

### all\_tools

```python
all_tools: list[AnyTool]
```

Returns a flattened list of all available tools.

### assert\_scores

```python
assert_scores: list[str] | Literal[True] = Field(
    default_factory=list
)
```

Scores to ensure are truthy, otherwise the agent task is marked as failed.

### caching

```python
caching: CacheMode | None = Config(default=None, repr=False)
```

How to handle cache\_control entries on inference messages.

### description

```python
description: Annotated[str, AfterValidator(dedent)] = ''
```

A brief description of the agent's purpose.

### hooks

```python
hooks: list[Hook] = Field(
    default_factory=list, exclude=True, repr=False
)
```

Hooks to run at various points in the agent's lifecycle.

### instructions

```python
instructions: Annotated[
    str | None,
    AfterValidator(lambda x: dedent(x) if x else x),
] = Config(default=None)
```

The agent's core instructions.

### label

```python
label: str | None = Config(default=None)
```

Specific label for tracing, otherwise derived from the name.

### max\_steps

```python
max_steps: int = Config(default=10)
```

The maximum number of steps (generation + tool calls).

### model

```python
model: str | Generator | None = Config(
    default=None, expose_as=str | None
)
```

Inference model (rigging generator or identifier).

### model\_name

```python
model_name: str | None
```

The model name if specified as a string, otherwise None.

### name

```python
name: str
```

The name of the agent.

### scorers

```python
scorers: ScorersLike[AgentResult] = Field(
    default_factory=list
)
```

Scorers to evaluate the agent output.

### stop\_conditions

```python
stop_conditions: list[StopCondition] = Field(
    default_factory=list
)
```

The logical condition for successfully stopping a run.

### tags

```python
tags: list[str] = Config(default_factory=lambda: ['agent'])
```

A list of tags associated with the agent.

### thread

```python
thread: Thread = Field(
    default_factory=Thread, exclude=True, repr=False
)
```

Stateful thread for this agent, for when otherwise not specified during execution.

### tool\_mode

```python
tool_mode: ToolMode = Config(default='auto', repr=False)
```

The tool calling mode to use.

### tools

```python
tools: Annotated[
    list[AnyTool | Toolset], SkipValidation
] = Config(default_factory=list)
```

Tools the agent can use.

### clone

```python
clone() -> te.Self
```

Clone the agent.

**Returns:**

* `Self`
  –A new Agent instance with the same attributes as this one.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def clone(self) -> te.Self:
    """
    Clone the agent.

    Returns:
        A new Agent instance with the same attributes as this one.
    """
    return self.model_copy(deep=True)
```


</Accordion>

### get\_prompt

```python
get_prompt() -> str
```

Generates the prompt for the agent based on its instructions.
This can be overridden by subclasses to provide custom behavior.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def get_prompt(self) -> str:
    """
    Generates the prompt for the agent based on its instructions.
    This can be overridden by subclasses to provide custom behavior.
    """
    prompt = "You are an agent that can use tools to assist with tasks."
    if self.instructions:
        prompt += f"\n\n<instructions>\n{self.instructions}\n</instructions>"
    return prompt
```


</Accordion>

### reset

```python
reset() -> Thread
```

Reset the agent's internal thread and returns the previous thread.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def reset(self) -> Thread:
    """Reset the agent's internal thread and returns the previous thread."""
    previous = self.thread
    self.thread = Thread()
    return previous
```


</Accordion>

### with\_

```python
with_(
    *,
    name: str | None = None,
    description: str | None = None,
    tags: list[str] | None = None,
    label: str | None = None,
    model: str | Generator | None = None,
    instructions: str | None = None,
    max_steps: int | None = None,
    caching: CacheMode | None = None,
    tools: list[AnyTool | Toolset] | None = None,
    tool_mode: ToolMode | None = None,
    hooks: list[Hook] | None = None,
    stop_conditions: list[StopCondition] | None = None,
    scorers: ScorersLike[AgentResult] | None = None,
    assert_scores: list[str] | Literal[True] | None = None,
    append: bool = False,
) -> te.Self
```

Clone the agent and modify its attributes.

**Returns:**

* `Self`
  –A new Agent instance with the modified attributes.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def with_(
    self,
    *,
    name: str | None = None,
    description: str | None = None,
    tags: list[str] | None = None,
    label: str | None = None,
    model: str | rg.Generator | None = None,
    instructions: str | None = None,
    max_steps: int | None = None,
    caching: rg.caching.CacheMode | None = None,
    tools: list[AnyTool | Toolset] | None = None,
    tool_mode: ToolMode | None = None,
    hooks: list[Hook] | None = None,
    stop_conditions: list[StopCondition] | None = None,
    scorers: ScorersLike[AgentResult] | None = None,
    assert_scores: list[str] | t.Literal[True] | None = None,
    append: bool = False,
) -> te.Self:
    """
    Clone the agent and modify its attributes.

    Returns:
        A new Agent instance with the modified attributes.
    """
    new = self.clone()

    new.name = name or new.name
    new.description = description or new.description
    new.label = label or new.label
    new.model = model or new.model
    new.instructions = instructions or new.instructions
    new.max_steps = max_steps or new.max_steps
    new.caching = caching or new.caching
    new.tool_mode = tool_mode or new.tool_mode

    if append:
        new.tags = [*new.tags, *(tags or [])]
        new.tools = [*new.tools, *(tools or [])]
        new.hooks = [*new.hooks, *(hooks or [])]
        new.stop_conditions = [*new.stop_conditions, *(stop_conditions or [])]
        new.scorers = [*new.scorers, *(scorers or [])]
        if isinstance(assert_scores, bool):
            new.assert_scores = assert_scores
        elif isinstance(new.assert_scores, list):
            new.assert_scores = [*new.assert_scores, *(assert_scores or [])]
        else:
            new.assert_scores = assert_scores or new.assert_scores
    else:
        new.tags = tags if tags is not None else new.tags
        new.tools = tools if tools is not None else new.tools
        new.hooks = hooks if hooks is not None else new.hooks
        new.stop_conditions = (
            stop_conditions if stop_conditions is not None else new.stop_conditions
        )
        new.scorers = scorers if scorers is not None else new.scorers
        new.assert_scores = assert_scores if assert_scores is not None else new.assert_scores

    return new
```


</Accordion>

AgentWarning
------------

Warning raised when an agent is used in a way that may not be safe or intended.

TaskAgent
---------

A specialized agent for running tasks with a focus on completion and reporting.
It extends the base Agent class to provide task-specific functionality.

* Automatically includes the `finish_task`, `give_up_on_task`, and `update_todo` tools.
* Installs a default stop\_never condition to trigger stalling behavior when no tools calls are made.
* Uses the `AgentStalled` event to handle stalled tasks by pushing the model to continue or finish the task.
backoff\_on\_error
------------------

```python
backoff_on_error(
    exception_types: type[Exception]
    | Iterable[type[Exception]],
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> Hook
```

Creates a hook that retries with exponential backoff when specific errors occur.

It listens for `AgentError` events and, if the error matches, waits for an
exponentially increasing duration before issuing a `Retry` reaction.

**Parameters:**

* **`exception_types`**
  (`type[Exception] | Iterable[type[Exception]]`)
  –An exception type or iterable of types to catch.
* **`max_tries`**
  (`int`, default:
  `8`
  )
  –The maximum number of retries before giving up.
* **`max_time`**
  (`float`, default:
  `300.0`
  )
  –The maximum total time in seconds to wait before giving up.
* **`base_factor`**
  (`float`, default:
  `1.0`
  )
  –The base duration (in seconds) for the backoff calculation.
* **`jitter`**
  (`bool`, default:
  `True`
  )
  –If True, adds a random jitter to the wait time to prevent synchronized retries.

**Returns:**

* `Hook`
  –An agent hook that implements the backoff logic.

<Accordion title="Source code in dreadnode/agent/hooks/backoff.py" icon="code">
```python
def backoff_on_error(
    exception_types: type[Exception] | t.Iterable[type[Exception]],
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> "Hook":
    """
    Creates a hook that retries with exponential backoff when specific errors occur.

    It listens for `AgentError` events and, if the error matches, waits for an
    exponentially increasing duration before issuing a `Retry` reaction.

    Args:
        exception_types: An exception type or iterable of types to catch.
        max_tries: The maximum number of retries before giving up.
        max_time: The maximum total time in seconds to wait before giving up.
        base_factor: The base duration (in seconds) for the backoff calculation.
        jitter: If True, adds a random jitter to the wait time to prevent synchronized retries.

    Returns:
        An agent hook that implements the backoff logic.
    """
    exceptions = (
        tuple(exception_types) if isinstance(exception_types, t.Iterable) else (exception_types,)
    )

    session_states: dict[ULID, BackoffState] = {}

    async def backoff_hook(event: "AgentEvent") -> "Reaction | None":
        state = session_states.setdefault(event.session_id, BackoffState())

        if isinstance(event, StepStart):
            if event.step > state.last_step_seen:
                state.reset(event.step)
            return None

        if not isinstance(event, AgentError) or not isinstance(event.error, exceptions):
            return None

        if state.start_time is None:
            state.start_time = time.monotonic()

        if state.tries >= max_tries:
            logger.warning(
                f"Backoff aborted for session {event.session_id}: maximum tries ({max_tries}) exceeded."
            )
            return None

        if (time.monotonic() - state.start_time) >= max_time:
            logger.warning(
                f"Backoff aborted for session {event.session_id}: maximum time ({max_time:.2f}s) exceeded."
            )
            return None

        state.tries += 1

        seconds = base_factor * (2 ** (state.tries - 1))
        if jitter:
            seconds += random.uniform(0, base_factor)  # noqa: S311 # nosec

        logger.warning(
            f"Backing off for {seconds:.2f}s (try {state.tries}/{max_tries}) on session {event.session_id} due to error: {event.error}"
        )

        await asyncio.sleep(seconds)
        return Retry()

    return backoff_hook
```


</Accordion>

backoff\_on\_ratelimit
----------------------

```python
backoff_on_ratelimit(
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> Hook
```

A convenient default backoff hook for common, ephemeral LLM errors.

This hook retries on `litellm.exceptions.RateLimitError` and `litellm.exceptions.APIError`
with an exponential backoff strategy for up to 5 minutes.

See `backoff_on_error` for more details.

**Parameters:**

* **`max_tries`**
  (`int`, default:
  `8`
  )
  –The maximum number of retries before giving up.
* **`max_time`**
  (`float`, default:
  `300.0`
  )
  –The maximum total time in seconds to wait before giving up.
* **`base_factor`**
  (`float`, default:
  `1.0`
  )
  –The base duration (in seconds) for the backoff calculation.
* **`jitter`**
  (`bool`, default:
  `True`
  )
  –If True, adds a random jitter to the wait time to prevent synchronized retries.

**Returns:**

* `Hook`
  –An agent hook that implements the backoff logic.

<Accordion title="Source code in dreadnode/agent/hooks/backoff.py" icon="code">
```python
def backoff_on_ratelimit(
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> "Hook":
    """
    A convenient default backoff hook for common, ephemeral LLM errors.

    This hook retries on `litellm.exceptions.RateLimitError` and `litellm.exceptions.APIError`
    with an exponential backoff strategy for up to 5 minutes.

    See `backoff_on_error` for more details.

    Args:
        max_tries: The maximum number of retries before giving up.
        max_time: The maximum total time in seconds to wait before giving up.
        base_factor: The base duration (in seconds) for the backoff calculation.
        jitter: If True, adds a random jitter to the wait time to prevent synchronized retries.

    Returns:
        An agent hook that implements the backoff logic.
    """
    import litellm.exceptions

    return backoff_on_error(
        (litellm.exceptions.RateLimitError, litellm.exceptions.APIError),
        max_time=max_time,
        max_tries=max_tries,
        base_factor=base_factor,
        jitter=jitter,
    )
```


</Accordion>

retry\_with\_feedback
---------------------

```python
retry_with_feedback(
    event_type: type[AgentEvent]
    | Callable[[AgentEvent], bool],
    feedback: str,
) -> Hook
```

Create a hook that provides feedback when the specified event occurs.

**Parameters:**

* **`event_type`**
  (`type[AgentEvent] | Callable[[AgentEvent], bool]`)
  –The type of event to listen for, or a callable that returns True if feedback should be provided.
* **`feedback`**
  (`str`)
  –The feedback message to provide when the event occurs.

**Returns:**

* `Hook`
  –A hook that provides feedback when the event occurs.

<Accordion title="Source code in dreadnode/agent/hooks/base.py" icon="code">
```python
def retry_with_feedback(
    event_type: "type[AgentEvent] | t.Callable[[AgentEvent], bool]", feedback: str
) -> "Hook":
    """
    Create a hook that provides feedback when the specified event occurs.

    Args:
        event_type: The type of event to listen for, or a callable that returns True if feedback should be provided.
        feedback: The feedback message to provide when the event occurs.

    Returns:
        A hook that provides feedback when the event occurs.
    """

    async def retry_with_feedback(event: "AgentEvent") -> "Reaction | None":
        if isinstance(event_type, type) and not isinstance(event, event_type):
            return None

        if inspect.isfunction(event_type) and not event_type(event):
            return None

        return RetryWithFeedback(feedback=feedback)

    return retry_with_feedback
```


</Accordion>

summarize\_when\_long
---------------------

```python
summarize_when_long(
    model: str | Generator | None = None,
    max_tokens: int = 100000,
    min_messages_to_keep: int = 5,
) -> Hook
```

Creates a hook to manage the agent's context window by summarizing the conversation history.

This hook operates in two ways:
1. **Proactively (on `StepStart`)**: Before each step, it checks the `input_tokens` from the
last `GenerationEnd` event. If it exceeds `max_tokens`, it summarizes older messages.
2. **Reactively (on `AgentError`)**: If the agent fails with a context length error,
it summarizes the history and retries the step.

**Parameters:**

* **`model`**
  (`str | Generator | None`, default:
  `None`
  )
  –The model identifier or generator to use for summarization, otherwise it will use the agent's model.
* **`max_tokens`**
  (`int`, default:
  `100000`
  )
  –The maximum number of tokens allowed in the context window before summarization is triggered
  (default is None, meaning no proactive summarization).
* **`min_messages_to_keep`**
  (`int`, default:
  `5`
  )
  –The minimum number of messages to retain after summarization (default is 5).

<Accordion title="Source code in dreadnode/agent/hooks/summarize.py" icon="code">
```python
@component
def summarize_when_long(
    model: str | rg.Generator | None = None,
    max_tokens: int = 100_000,
    min_messages_to_keep: int = 5,
) -> "Hook":
    """
    Creates a hook to manage the agent's context window by summarizing the conversation history.

    This hook operates in two ways:
    1.  **Proactively (on `StepStart`)**: Before each step, it checks the `input_tokens` from the
        last `GenerationEnd` event. If it exceeds `max_tokens`, it summarizes older messages.
    2.  **Reactively (on `AgentError`)**: If the agent fails with a context length error,
        it summarizes the history and retries the step.

    Args:
        model: The model identifier or generator to use for summarization, otherwise it will use the agent's model.
        max_tokens: The maximum number of tokens allowed in the context window before summarization is triggered
            (default is None, meaning no proactive summarization).
        min_messages_to_keep: The minimum number of messages to retain after summarization (default is 5).
    """

    if min_messages_to_keep < 2:
        raise ValueError("min_messages_to_keep must be at least 2.")

    @component
    async def summarize_when_long(  # noqa: PLR0912
        event: AgentEvent,
        *,
        model: str | rg.Generator | None = Config(  # noqa: B008
            model,
            help="Model to use for summarization - fallback to the agent model",
            expose_as=str | None,
        ),
        max_tokens: int | None = Config(
            max_tokens,
            help="Maximum number of tokens observed before summarization is triggered",
        ),
        min_messages_to_keep: int = Config(
            5, help="Minimum number of messages to retain after summarization"
        ),
    ) -> Reaction | None:
        should_summarize = False

        # Proactive check using the last known token count
        if max_tokens is not None and isinstance(event, StepStart):
            last_token_count = _get_last_input_tokens(event)
            if last_token_count > 0 and last_token_count > max_tokens:
                should_summarize = True

        # Reactive check based on the error message
        elif isinstance(event, AgentError):
            if _is_context_length_error(event.error):
                should_summarize = True

        if not should_summarize:
            return None

        summarizer_model = model or event.agent.model
        if summarizer_model is None:
            return None

        messages = list(event.messages)

        # Check if we have enough messages to summarize
        if len(messages) <= min_messages_to_keep:
            return None

        # Exclude the system message from the summarization process.
        system_message: rg.Message | None = (
            messages.pop(0) if messages and messages[0].role == "system" else None
        )

        # Find the best point to summarize by walking the message list once.
        # A boundary is valid after a simple assistant message or a finished tool block.
        best_summarize_boundary = 0
        for i, message in enumerate(messages):
            # If the remaining messages are less than or equal to our minimum, we can't slice any further.
            if len(messages) - i <= min_messages_to_keep:
                break

            # Condition 1: The message is an assistant response without tool calls.
            is_simple_assistant = message.role == "assistant" and not getattr(
                message, "tool_calls", None
            )

            # Condition 2: The message is the last in a block of tool responses.
            is_last_tool_in_block = message.role == "tool" and (
                i + 1 == len(messages) or messages[i + 1].role != "tool"
            )

            if is_simple_assistant or is_last_tool_in_block:
                best_summarize_boundary = i + 1

        if best_summarize_boundary == 0:
            return None  # No valid slice point was found.

        messages_to_summarize = messages[:best_summarize_boundary]
        messages_to_keep = messages[best_summarize_boundary:]

        if not messages_to_summarize:
            return None

        # Generate the summary and rebuild the messages
        summary = await summarize_conversation.bind(summarizer_model)(
            "\n".join(str(msg) for msg in messages_to_summarize)
        )
        summary_content = (
            f"<conversation-summary messages={len(messages_to_summarize)}>\n"
            f"{summary.summary}\n"
            "</conversation-summary>"
        )

        new_messages: list[rg.Message] = []
        if system_message:
            new_messages.append(system_message)
        new_messages.append(rg.Message("user", summary_content, metadata={"summary": True}))
        new_messages.extend(messages_to_keep)

        return (
            Continue(messages=new_messages)
            if isinstance(event, StepStart)
            else Retry(messages=new_messages)
        )

    return summarize_when_long
```


</Accordion>

tool\_metrics
-------------

```python
tool_metrics(*, detailed: bool = False) -> Hook
```

Creates an agent hook to log metrics about tool usage, execution time, and success rates.

**Parameters:**

* **`detailed`**
  (`bool`, default:
  `False`
  )
  –If True, logs metrics for each specific tool in addition to general stats.
  If False, only logs aggregate statistics across all tools.

**Returns:**

* `Hook`
  –An async hook function that can be registered with an agent.

<Accordion title="Source code in dreadnode/agent/hooks/metrics.py" icon="code">
```python
def tool_metrics(*, detailed: bool = False) -> Hook:
    """
    Creates an agent hook to log metrics about tool usage, execution time, and success rates.

    Args:
        detailed: If True, logs metrics for each specific tool in addition to general stats.
                  If False, only logs aggregate statistics across all tools.

    Returns:
        An async hook function that can be registered with an agent.
    """
    _start_times: dict[str, datetime] = {}

    @component
    async def tool_metrics(
        event: AgentEvent,
        *,
        detailed: bool = Config(
            default=detailed,
            help="If True, logs metrics for each specific tool in addition to general stats.",
        ),
    ) -> None:
        """The actual hook implementation that processes agent events."""
        from dreadnode import log_metric

        if isinstance(event, ToolStart):
            log_metric("tool/total_count", 1, step=event.step, mode="count")
            _start_times[event.tool_call.id] = event.timestamp

            if detailed:
                tool_name = event.tool_call.name
                log_metric(f"tool/count.{tool_name}", 1, step=event.step, mode="count")

        elif isinstance(event, ToolEnd):
            tool_name = event.tool_call.name
            start_time = _start_times.pop(event.tool_call.id, event.timestamp)
            duration_seconds = (event.timestamp - start_time).total_seconds()
            errored = "error" in event.message.metadata

            log_metric("tool/total_time", duration_seconds, step=event.step, mode="sum")
            log_metric("tool/success_rate", 0 if errored else 1, step=event.step, mode="avg")

            if errored:
                log_metric("tool/failed_count", 1, step=event.step, mode="count")

            if detailed:
                log_metric(
                    f"tool/time.{tool_name}",
                    duration_seconds,
                    step=event.step,
                    mode="sum",
                )
                log_metric(
                    f"tool/avg_time.{tool_name}",
                    duration_seconds,
                    step=event.step,
                    mode="avg",
                )
                log_metric(
                    f"tool/success_rate.{tool_name}",
                    0 if errored else 1,
                    step=event.step,
                    mode="avg",
                )

                if errored:
                    log_metric(
                        f"tool/failed_count.{tool_name}",
                        1,
                        step=event.step,
                        mode="count",
                    )

    return tool_metrics
```


</Accordion>
AgentEvent
----------

```python
AgentEvent(
    session_id: ULID,
    agent: Agent,
    thread: Thread,
    messages: list[Message],
    events: list[AgentEvent],
    *,
    timestamp: datetime = (
        lambda: datetime.now(timezone.utc)
    )(),
)
```

### agent

```python
agent: Agent = field(repr=False)
```

The agent associated with this event.

### estimated\_cost

```python
estimated_cost: float | None
```

Estimates the cost of the agent run based on total token usage and model pricing.

### events

```python
events: list[AgentEvent] = field(repr=False)
```

Current events for this run session.

### last\_usage

```python
last_usage: Usage | None
```

Returns the usage from the last generation event, if available.

### messages

```python
messages: list[Message] = field(repr=False)
```

Current messages for this run session.

### session\_id

```python
session_id: ULID = field(repr=False)
```

The unique identifier for the agent run session.

### thread

```python
thread: Thread = field(repr=False)
```

The thread associated with this event.

### timestamp

```python
timestamp: datetime = field(
    default_factory=lambda: now(utc),
    kw_only=True,
    repr=False,
)
```

The timestamp of when the event occurred (UTC).

### total\_usage

```python
total_usage: Usage
```

Aggregates the usage from all events in the run session.

### format\_as\_panel

```python
format_as_panel(*, truncate: bool = False) -> Panel
```

Renders the event as a rich Panel. Can be customized by higher-level systems.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def format_as_panel(self, *, truncate: bool = False) -> Panel:  # noqa: ARG002
    """Renders the event as a rich Panel. Can be customized by higher-level systems."""
    return Panel(
        Text(repr(self)),
        title=f"[dim]{self.__class__.__name__}[/dim]",
        border_style="dim",
    )
```


</Accordion>

### get\_events\_by\_type

```python
get_events_by_type(
    event_type: type[AgentEventT],
) -> list[AgentEventT]
```

Returns all events of the specified type from the thread's events.

**Parameters:**

* **`event_type`**
  (`type[AgentEventT]`)
  –The type of event to search for.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def get_events_by_type(self, event_type: type[AgentEventT]) -> list[AgentEventT]:
    """
    Returns all events of the specified type from the thread's events.

    Args:
        event_type: The type of event to search for.
    """
    return [event for event in self.events if isinstance(event, event_type)]
```


</Accordion>

### get\_latest\_event\_by\_type

```python
get_latest_event_by_type(
    event_type: type[AgentEventT],
) -> AgentEventT | None
```

Returns the latest event of the specified type from the thread's events.

**Parameters:**

* **`event_type`**
  (`type[AgentEventT]`)
  –The type of event to search for.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def get_latest_event_by_type(self, event_type: type[AgentEventT]) -> AgentEventT | None:
    """
    Returns the latest event of the specified type from the thread's events.

    Args:
        event_type: The type of event to search for.
    """
    for event in reversed(self.events):
        if isinstance(event, event_type):
            return event
    return None
```


</Accordion>

AgentEventInStep
----------------

```python
AgentEventInStep(
    session_id: ULID,
    agent: Agent,
    thread: Thread,
    messages: list[Message],
    events: list[AgentEvent],
    *,
    timestamp: datetime = (
        lambda: datetime.now(timezone.utc)
    )(),
)
```

### step

```python
step: int
```

Returns the current step number.


StopCondition
-------------

```python
StopCondition(
    func: Callable[[Sequence[AgentEvent]], bool],
    name: str | None = None,
)
```

A condition that determines when an agent's run should stop, defined by a callable.
Conditions can be combined using & (AND) and | (OR).

Initializes the StopCondition.

**Parameters:**

* **`func`**
  (`Callable[[Sequence[AgentEvent]], bool]`)
  –A callable that takes a sequence of events and returns True if the run should stop.
* **`name`**
  (`str | None`, default:
  `None`
  )
  –An optional name for the condition for representation.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __init__(self, func: t.Callable[[Sequence[AgentEvent]], bool], name: str | None = None):
    """
    Initializes the StopCondition.

    Args:
        func: A callable that takes a sequence of events and returns True if the run should stop.
        name: An optional name for the condition for representation.
    """

    if name is None:
        unwrapped = inspect.unwrap(func)
        name = get_callable_name(unwrapped, short=True)

    self.func = func
    """The function that defines the stop condition."""
    self.name = name
    """A human-readable name for the condition."""
```


</Accordion>

### func

```python
func = func
```

The function that defines the stop condition.

### name

```python
name = name
```

A human-readable name for the condition.

### \_\_and\_\_

```python
__and__(other: StopCondition) -> StopCondition
```

Combines this condition with another using AND logic.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __and__(self, other: "StopCondition") -> "StopCondition":
    """Combines this condition with another using AND logic."""
    return and_(self, other)
```


</Accordion>

### \_\_or\_\_

```python
__or__(other: StopCondition) -> StopCondition
```

Combines this condition with another using OR logic.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __or__(self, other: "StopCondition") -> "StopCondition":
    """Combines this condition with another using OR logic."""
    return or_(self, other)
```


</Accordion>

and\_
-----

```python
and_(
    condition: StopCondition,
    other: StopCondition,
    *,
    name: str | None = None,
) -> StopCondition
```

Perform a logical AND with two stop conditions.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def and_(
    condition: StopCondition, other: StopCondition, *, name: str | None = None
) -> StopCondition:
    """Perform a logical AND with two stop conditions."""

    def stop(events: Sequence[AgentEvent]) -> bool:
        return condition(events) and other(events)

    return StopCondition(stop, name=name or f"({condition.name}_and_{other.name})")
```


</Accordion>

elapsed\_time
-------------

```python
elapsed_time(max_seconds: int) -> StopCondition
```

Stop if the total execution time exceeds a given duration.

**Parameters:**

* **`max_seconds`**
  (`int`)
  –The maximum number of seconds the agent is allowed to run.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def elapsed_time(max_seconds: int) -> StopCondition:
    """
    Stop if the total execution time exceeds a given duration.

    Args:
        max_seconds: The maximum number of seconds the agent is allowed to run.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        if len(events) < 2:
            return False

        first_event = events[0]
        last_event = events[-1]

        delta = last_event.timestamp - first_event.timestamp
        return delta.total_seconds() > max_seconds

    return StopCondition(stop, name="stop_on_elapsed_time")
```


</Accordion>

estimated\_cost
---------------

```python
estimated_cost(limit: float) -> StopCondition
```

Stop if the estimated cost of LLM generations exceeds a limit.

**Parameters:**

* **`limit`**
  (`float`)
  –The maximum cost allowed (USD).

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def estimated_cost(limit: float) -> StopCondition:
    """
    Stop if the estimated cost of LLM generations exceeds a limit.

    Args:
        limit: The maximum cost allowed (USD).
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        last_event = next((e for e in reversed(events)), None)
        if not last_event:
            return False
        estimated_cost = last_event.estimated_cost
        return estimated_cost > limit if estimated_cost else False

    return StopCondition(stop, name="stop_on_estimated_cost")
```


</Accordion>

generation\_count
-----------------

```python
generation_count(max_generations: int) -> StopCondition
```

Stop after a maximum number of LLM generations (inference calls).

This is slightly more robust than using `max_steps` as
retry calls to the LLM will also count towards this limit.

**Parameters:**

* **`max_generations`**
  (`int`)
  –The maximum number of LLM generations to allow.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def generation_count(max_generations: int) -> StopCondition:
    """
    Stop after a maximum number of LLM generations (inference calls).

    This is slightly more robust than using `max_steps` as
    retry calls to the LLM will also count towards this limit.

    Args:
        max_generations: The maximum number of LLM generations to allow.
    """

    @component
    def stop(
        events: Sequence[AgentEvent], *, max_generations: int = Config(max_generations)
    ) -> bool:
        generation_count = sum(1 for event in events if isinstance(event, GenerationEnd))
        return generation_count >= max_generations

    return StopCondition(stop, name="stop_on_generation_count")
```


</Accordion>

never
-----

```python
never() -> StopCondition
```

A condition that never stops the agent.

This is generally useful for triggering stalling
conditions when an agent does not issue any tool
calls, and a hook reaction will be used.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def never() -> StopCondition:
    """
    A condition that never stops the agent.

    This is generally useful for triggering stalling
    conditions when an agent does not issue any tool
    calls, and a hook reaction will be used.
    """

    def stop(_: Sequence[AgentEvent]) -> bool:
        return False

    return StopCondition(stop, name="stop_never")
```


</Accordion>

no\_new\_tool\_used
-------------------

```python
no_new_tool_used(for_steps: int) -> StopCondition
```

Stop if the agent goes for a number of steps without using a new tool.

**Parameters:**

* **`for_steps`**
  (`int`)
  –The number of consecutive steps without a new tool use
  before the agent should stop.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def no_new_tool_used(for_steps: int) -> StopCondition:
    """
    Stop if the agent goes for a number of steps without using a new tool.

    Args:
        for_steps: The number of consecutive steps without a new tool use
            before the agent should stop.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        step_starts = [e for e in events if isinstance(e, StepStart)]
        if len(step_starts) < for_steps:
            return False

        # Get events from the last `for_steps` steps
        relevant_events = events[events.index(step_starts[-for_steps]) :]

        used_tools_in_period = {e.tool_call.name for e in relevant_events if isinstance(e, ToolEnd)}

        # Find tools used before this period
        prior_events = events[: events.index(step_starts[-for_steps])]
        prior_tools = {e.tool_call.name for e in prior_events if isinstance(e, ToolEnd)}

        # If any tool used in the current period is new, don't stop
        return used_tools_in_period - prior_tools != set()

    return StopCondition(stop, name="stop_on_no_new_tool")
```


</Accordion>

or\_
----

```python
or_(
    condition: StopCondition,
    other: StopCondition,
    *,
    name: str | None = None,
) -> StopCondition
```

Perform a logical OR with two stop conditions.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def or_(
    condition: StopCondition, other: StopCondition, *, name: str | None = None
) -> StopCondition:
    """Perform a logical OR with two stop conditions."""

    def stop(events: Sequence[AgentEvent]) -> bool:
        return condition(events) or other(events)

    return StopCondition(stop, name=name or f"({condition.name}_or_{other.name})")
```


</Accordion>

output
------

```python
output(
    pattern: str | Pattern[str],
    *,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition
```

Stop if a specific string or pattern is mentioned in the last generated message.

**Parameters:**

* **`pattern`**
  (`str | Pattern[str]`)
  –The string or compiled regex pattern to search for.
* **`case_sensitive`**
  (`bool`, default:
  `False`
  )
  –If True, the match is case-sensitive. Defaults to False.
* **`exact`**
  (`bool`, default:
  `False`
  )
  –If True, performs an exact string match instead of containment. Defaults to False.
* **`regex`**
  (`bool`, default:
  `False`
  )
  –If True, treats the `pattern` string as a regular expression. Defaults to False.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def output(
    pattern: str | re.Pattern[str],
    *,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition:
    """
    Stop if a specific string or pattern is mentioned in the last generated message.

    Args:
        pattern: The string or compiled regex pattern to search for.
        case_sensitive: If True, the match is case-sensitive. Defaults to False.
        exact: If True, performs an exact string match instead of containment. Defaults to False.
        regex: If True, treats the `pattern` string as a regular expression. Defaults to False.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        if not events:
            return False

        last_generation = next((e for e in reversed(events) if isinstance(e, GenerationEnd)), None)
        if not last_generation:
            return False

        text = last_generation.message.content
        found = False

        if isinstance(pattern, re.Pattern) or regex:
            compiled = pattern
            if isinstance(pattern, str):
                flags = 0 if case_sensitive else re.IGNORECASE
                compiled = re.compile(pattern, flags)

            if isinstance(compiled, re.Pattern):  # Make type checker happy
                found = bool(compiled.search(text))
        elif exact:
            found = text == pattern if case_sensitive else text.lower() == str(pattern).lower()
        else:  # Default to substring containment
            search_text = text if case_sensitive else text.lower()
            search_pattern = str(pattern) if case_sensitive else str(pattern).lower()
            found = search_pattern in search_text

        return found

    return StopCondition(stop, name="stop_on_output")
```


</Accordion>

token\_usage
------------

```python
token_usage(
    limit: int,
    *,
    mode: Literal["total", "in", "out"] = "total",
) -> StopCondition
```

Stop if the token usage exceeds a specified limit.

**Parameters:**

* **`limit`**
  (`int`)
  –The maximum number of tokens allowed.
* **`mode`**
  (`Literal['total', 'in', 'out']`, default:
  `'total'`
  )
  –Which token count to consider:
  - "total": Total tokens (default)
  - "in": Input tokens only
  - "out": Output tokens only

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def token_usage(limit: int, *, mode: t.Literal["total", "in", "out"] = "total") -> StopCondition:
    """
    Stop if the token usage exceeds a specified limit.

    Args:
        limit: The maximum number of tokens allowed.
        mode: Which token count to consider:
            - "total": Total tokens (default)
            - "in": Input tokens only
            - "out": Output tokens only
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        last_event = next((e for e in reversed(events)), None)
        if not last_event:
            return False

        usage = last_event.total_usage
        token_count = (
            usage.total_tokens
            if mode == "total"
            else (usage.input_tokens if mode == "in" else usage.output_tokens)
        )

        return token_count > limit

    return StopCondition(stop, name="stop_on_token_usage")
```


</Accordion>

tool\_error
-----------

```python
tool_error(tool_name: str | None = None) -> StopCondition
```

Stop if any tool call results in an gracefully handled error.

**Parameters:**

* **`tool_name`**
  (`str | None`, default:
  `None`
  )
  –If specified, only considers errors from this tool.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_error(tool_name: str | None = None) -> StopCondition:
    """
    Stop if any tool call results in an gracefully handled error.

    Args:
        tool_name: If specified, only considers errors from this tool.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        for event in reversed(events):
            if isinstance(event, ToolEnd):
                if tool_name and event.tool_call.name != tool_name:
                    continue

                if "error" in event.message.metadata:
                    return True

        return False

    return StopCondition(stop, name="stop_on_tool_error")
```


</Accordion>

tool\_output
------------

```python
tool_output(
    pattern: str | Pattern[str],
    *,
    tool_name: str | None = None,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition
```

Stop if a specific string or pattern is found in the output of a tool call.

**Parameters:**

* **`pattern`**
  (`str | Pattern[str]`)
  –The string or compiled regex pattern to search for.
* **`tool_name`**
  (`str | None`, default:
  `None`
  )
  –If specified, only considers outputs from this tool.
* **`case_sensitive`**
  (`bool`, default:
  `False`
  )
  –If True, the match is case-sensitive. Defaults to False.
* **`exact`**
  (`bool`, default:
  `False`
  )
  –If True, performs an exact string match instead of containment. Defaults to False.
* **`regex`**
  (`bool`, default:
  `False`
  )
  –If True, treats the `pattern` string as a regular expression. Defaults to False.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_output(
    pattern: str | re.Pattern[str],
    *,
    tool_name: str | None = None,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition:
    """
    Stop if a specific string or pattern is found in the output of a tool call.

    Args:
        pattern: The string or compiled regex pattern to search for.
        tool_name: If specified, only considers outputs from this tool.
        case_sensitive: If True, the match is case-sensitive. Defaults to False.
        exact: If True, performs an exact string match instead of containment. Defaults to False.
        regex: If True, treats the `pattern` string as a regular expression. Defaults to False.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        for event in reversed(events):
            if isinstance(event, ToolEnd):
                if tool_name and event.tool_call.name != tool_name:
                    continue

                output = event.message.content
                if output is None:
                    continue

                text = str(output)
                found = False

                if isinstance(pattern, re.Pattern) or regex:
                    compiled = pattern
                    if isinstance(pattern, str):
                        flags = 0 if case_sensitive else re.IGNORECASE
                        compiled = re.compile(pattern, flags)

                    if isinstance(compiled, re.Pattern):  # Make type checker happy
                        found = bool(compiled.search(text))
                elif exact:
                    found = (
                        text == pattern if case_sensitive else text.lower() == str(pattern).lower()
                    )
                else:  # Default to substring containment
                    search_text = text if case_sensitive else text.lower()
                    search_pattern = str(pattern) if case_sensitive else str(pattern).lower()
                    found = search_pattern in search_text

                if found:
                    return True

        return False

    return StopCondition(stop, name="stop_on_tool_output")
```


</Accordion>

tool\_use
---------

```python
tool_use(
    tool_name: str, *, count: int = 1
) -> StopCondition
```

Stop after a specific tool has been successfully used.

**Parameters:**

* **`tool_name`**
  (`str`)
  –The name of the tool to monitor.
* **`count`**
  (`int`, default:
  `1`
  )
  –The number of times the tool must be used to trigger stopping. Defaults to 1.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_use(tool_name: str, *, count: int = 1) -> StopCondition:
    """
    Stop after a specific tool has been successfully used.

    Args:
        tool_name: The name of the tool to monitor.
        count: The number of times the tool must be used to trigger stopping. Defaults to 1.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        tool_count = sum(
            1 for e in events if isinstance(e, ToolEnd) and e.tool_call.name == tool_name
        )
        return tool_count >= count

    return StopCondition(stop, name="stop_on_tool_use")
```


</Accordion>
Thread
------

### events

```python
events: list[AgentEvent] = Field(default_factory=list)
```

All events that have occurred during the use of this thread.

### last\_usage

```python
last_usage: Usage | None
```

Returns the usage from the last generation event, if available.

### messages

```python
messages: list[Message] = Field(default_factory=list)
```

The current messages for this thread.

### total\_usage

```python
total_usage: Usage
```

Aggregates the usage from all events in the thread.