---
title: dreadnode.agent
---

{/*
::: dreadnode.agent.agent
::: dreadnode.agent.hooks
::: dreadnode.agent.events
::: dreadnode.agent.reactions
::: dreadnode.agent.result
::: dreadnode.agent.stop
::: dreadnode.agent.thread
*/}

Agent
-----

Agent abstraction for applying tools, event logic, and message state to LLM generation.

### all\_tools

```python
all_tools: list[AnyTool]
```

Returns a flattened list of all available tools.

### assert\_scores

```python
assert_scores: list[str] | Literal[True] = Field(
    default_factory=list
)
```

Scores to ensure are truthy, otherwise the agent task is marked as failed.

### caching

```python
caching: CacheMode | None = Config(default=None, repr=False)
```

How to handle cache\_control entries on inference messages.

### description

```python
description: Annotated[str, AfterValidator(dedent)] = ''
```

A brief description of the agent's purpose.

### hooks

```python
hooks: list[Hook] = Field(
    default_factory=list, exclude=True, repr=False
)
```

Hooks to run at various points in the agent's lifecycle.

### instructions

```python
instructions: Annotated[
    str | None,
    AfterValidator(lambda x: dedent(x) if x else x),
] = Config(default=None)
```

The agent's core instructions.

### label

```python
label: str | None = Config(default=None)
```

Specific label for tracing, otherwise derived from the name.

### max\_steps

```python
max_steps: int = Config(default=10)
```

The maximum number of steps (generation + tool calls).

### model

```python
model: str | Generator | None = Config(
    default=None, expose_as=str | None
)
```

Inference model (rigging generator or identifier).

### model\_name

```python
model_name: str | None
```

The model name if specified as a string, otherwise None.

### name

```python
name: str
```

The name of the agent.

### scorers

```python
scorers: ScorersLike[AgentResult] = Field(
    default_factory=list
)
```

Scorers to evaluate the agent output.

### stop\_conditions

```python
stop_conditions: list[StopCondition] = Field(
    default_factory=list
)
```

The logical condition for successfully stopping a run.

### tags

```python
tags: list[str] = Config(default_factory=lambda: ['agent'])
```

A list of tags associated with the agent.

### thread

```python
thread: Thread = Field(
    default_factory=Thread, exclude=True, repr=False
)
```

Stateful thread for this agent, for when otherwise not specified during execution.

### tool\_mode

```python
tool_mode: ToolMode = Config(default='auto', repr=False)
```

The tool calling mode to use.

### tools

```python
tools: Annotated[
    list[AnyTool | Toolset], SkipValidation
] = Config(default_factory=list)
```

Tools the agent can use.

### clone

```python
clone() -> te.Self
```

Clone the agent.

**Returns:**

* `Self`
  –A new Agent instance with the same attributes as this one.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def clone(self) -> te.Self:
    """
    Clone the agent.

    Returns:
        A new Agent instance with the same attributes as this one.
    """
    return self.model_copy(deep=True)
```


</Accordion>

### get\_prompt

```python
get_prompt() -> str
```

Generates the prompt for the agent based on its instructions.
This can be overridden by subclasses to provide custom behavior.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def get_prompt(self) -> str:
    """
    Generates the prompt for the agent based on its instructions.
    This can be overridden by subclasses to provide custom behavior.
    """
    prompt = "You are an agent that can use tools to assist with tasks."
    if self.instructions:
        prompt += f"\n\n<instructions>\n{self.instructions}\n</instructions>"
    return prompt
```


</Accordion>

### reset

```python
reset() -> Thread
```

Reset the agent's internal thread and returns the previous thread.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def reset(self) -> Thread:
    """Reset the agent's internal thread and returns the previous thread."""
    previous = self.thread
    self.thread = Thread()
    return previous
```


</Accordion>

### with\_

```python
with_(
    *,
    name: str | None = None,
    description: str | None = None,
    tags: list[str] | None = None,
    label: str | None = None,
    model: str | Generator | None = None,
    instructions: str | None = None,
    max_steps: int | None = None,
    caching: CacheMode | None = None,
    tools: list[AnyTool | Toolset] | None = None,
    tool_mode: ToolMode | None = None,
    hooks: list[Hook] | None = None,
    stop_conditions: list[StopCondition] | None = None,
    scorers: ScorersLike[AgentResult] | None = None,
    assert_scores: list[str] | Literal[True] | None = None,
    append: bool = False,
) -> te.Self
```

Clone the agent and modify its attributes.

**Returns:**

* `Self`
  –A new Agent instance with the modified attributes.

<Accordion title="Source code in dreadnode/agent/agent.py" icon="code">
```python
def with_(
    self,
    *,
    name: str | None = None,
    description: str | None = None,
    tags: list[str] | None = None,
    label: str | None = None,
    model: str | rg.Generator | None = None,
    instructions: str | None = None,
    max_steps: int | None = None,
    caching: rg.caching.CacheMode | None = None,
    tools: list[AnyTool | Toolset] | None = None,
    tool_mode: ToolMode | None = None,
    hooks: list[Hook] | None = None,
    stop_conditions: list[StopCondition] | None = None,
    scorers: ScorersLike[AgentResult] | None = None,
    assert_scores: list[str] | t.Literal[True] | None = None,
    append: bool = False,
) -> te.Self:
    """
    Clone the agent and modify its attributes.

    Returns:
        A new Agent instance with the modified attributes.
    """
    new = self.clone()

    new.name = name or new.name
    new.description = description or new.description
    new.label = label or new.label
    new.model = model or new.model
    new.instructions = instructions or new.instructions
    new.max_steps = max_steps or new.max_steps
    new.caching = caching or new.caching
    new.tool_mode = tool_mode or new.tool_mode

    if append:
        new.tags = [*new.tags, *(tags or [])]
        new.tools = [*new.tools, *(tools or [])]
        new.hooks = [*new.hooks, *(hooks or [])]
        new.stop_conditions = [*new.stop_conditions, *(stop_conditions or [])]
        new.scorers = [*new.scorers, *(scorers or [])]
        if isinstance(assert_scores, bool):
            new.assert_scores = assert_scores
        elif isinstance(new.assert_scores, list):
            new.assert_scores = [*new.assert_scores, *(assert_scores or [])]
        else:
            new.assert_scores = assert_scores or new.assert_scores
    else:
        new.tags = tags if tags is not None else new.tags
        new.tools = tools if tools is not None else new.tools
        new.hooks = hooks if hooks is not None else new.hooks
        new.stop_conditions = (
            stop_conditions if stop_conditions is not None else new.stop_conditions
        )
        new.scorers = scorers if scorers is not None else new.scorers
        new.assert_scores = assert_scores if assert_scores is not None else new.assert_scores

    # Retrigger model_post_init functions to ensure consistency
    new.model_post_init(None)

    return new
```


</Accordion>

AgentWarning
------------

Warning raised when an agent is used in a way that may not be safe or intended.

RegexRefAgent
-------------

An agent mixin that allows for dynamic references of prior text using regex patterns in tool arguments.
This helps prevent repeating large amounts of prior text in tool calls.

Instructions are automatically added to the agent's instructions to guide usage of the {find:} syntax
along with a hook that resolves these references during tool calls.

TaskAgent
---------

A specialized agent mixin for running tasks with a focus on completion and reporting.
It extends the base Agent class to provide task-specific functionality.

* Automatically includes the `finish_task`, `give_up_on_task`, and `update_todo` tools.
* Installs a default stop\_never condition to trigger stalling behavior when no tools calls are made.
* Uses the `AgentStalled` event to handle stalled tasks by pushing the model to continue or finish the task.
backoff\_on\_error
------------------

```python
backoff_on_error(
    exception_types: type[Exception]
    | Iterable[type[Exception]],
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> Hook
```

Creates a hook that retries with exponential backoff when specific errors occur.

It listens for `AgentError` events and, if the error matches, waits for an
exponentially increasing duration before issuing a `Retry` reaction.

**Parameters:**

* **`exception_types`**
  (`type[Exception] | Iterable[type[Exception]]`)
  –An exception type or iterable of types to catch.
* **`max_tries`**
  (`int`, default:
  `8`
  )
  –The maximum number of retries before giving up.
* **`max_time`**
  (`float`, default:
  `300.0`
  )
  –The maximum total time in seconds to wait before giving up.
* **`base_factor`**
  (`float`, default:
  `1.0`
  )
  –The base duration (in seconds) for the backoff calculation.
* **`jitter`**
  (`bool`, default:
  `True`
  )
  –If True, adds a random jitter to the wait time to prevent synchronized retries.

**Returns:**

* `Hook`
  –An agent hook that implements the backoff logic.

<Accordion title="Source code in dreadnode/agent/hooks/backoff.py" icon="code">
```python
def backoff_on_error(
    exception_types: type[Exception] | t.Iterable[type[Exception]],
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> "Hook":
    """
    Creates a hook that retries with exponential backoff when specific errors occur.

    It listens for `AgentError` events and, if the error matches, waits for an
    exponentially increasing duration before issuing a `Retry` reaction.

    Args:
        exception_types: An exception type or iterable of types to catch.
        max_tries: The maximum number of retries before giving up.
        max_time: The maximum total time in seconds to wait before giving up.
        base_factor: The base duration (in seconds) for the backoff calculation.
        jitter: If True, adds a random jitter to the wait time to prevent synchronized retries.

    Returns:
        An agent hook that implements the backoff logic.
    """
    exceptions = (
        tuple(exception_types) if isinstance(exception_types, t.Iterable) else (exception_types,)
    )

    session_states: dict[ULID, BackoffState] = {}

    async def backoff_hook(event: "AgentEvent") -> "Reaction | None":
        state = session_states.setdefault(event.session_id, BackoffState())

        if isinstance(event, StepStart):
            if event.step > state.last_step_seen:
                state.reset(event.step)
            return None

        if not isinstance(event, AgentError) or not isinstance(event.error, exceptions):
            return None

        if state.start_time is None:
            state.start_time = time.monotonic()

        if state.tries >= max_tries:
            logger.warning(
                f"Backoff aborted for session {event.session_id}: maximum tries ({max_tries}) exceeded."
            )
            return None

        if (time.monotonic() - state.start_time) >= max_time:
            logger.warning(
                f"Backoff aborted for session {event.session_id}: maximum time ({max_time:.2f}s) exceeded."
            )
            return None

        state.tries += 1

        seconds = base_factor * (2 ** (state.tries - 1))
        if jitter:
            seconds += random.uniform(0, base_factor)  # noqa: S311 # nosec

        logger.warning(
            f"Backing off for {seconds:.2f}s (try {state.tries}/{max_tries}) on session {event.session_id} due to error: {event.error}"
        )

        await asyncio.sleep(seconds)
        return Retry()

    return backoff_hook
```


</Accordion>

backoff\_on\_ratelimit
----------------------

```python
backoff_on_ratelimit(
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> Hook
```

A convenient default backoff hook for common, ephemeral LLM errors.

This hook retries on `litellm.exceptions.RateLimitError` and `litellm.exceptions.APIError`
with an exponential backoff strategy for up to 5 minutes.

See `backoff_on_error` for more details.

**Parameters:**

* **`max_tries`**
  (`int`, default:
  `8`
  )
  –The maximum number of retries before giving up.
* **`max_time`**
  (`float`, default:
  `300.0`
  )
  –The maximum total time in seconds to wait before giving up.
* **`base_factor`**
  (`float`, default:
  `1.0`
  )
  –The base duration (in seconds) for the backoff calculation.
* **`jitter`**
  (`bool`, default:
  `True`
  )
  –If True, adds a random jitter to the wait time to prevent synchronized retries.

**Returns:**

* `Hook`
  –An agent hook that implements the backoff logic.

<Accordion title="Source code in dreadnode/agent/hooks/backoff.py" icon="code">
```python
def backoff_on_ratelimit(
    *,
    max_tries: int = 8,
    max_time: float = 300.0,
    base_factor: float = 1.0,
    jitter: bool = True,
) -> "Hook":
    """
    A convenient default backoff hook for common, ephemeral LLM errors.

    This hook retries on `litellm.exceptions.RateLimitError` and `litellm.exceptions.APIError`
    with an exponential backoff strategy for up to 5 minutes.

    See `backoff_on_error` for more details.

    Args:
        max_tries: The maximum number of retries before giving up.
        max_time: The maximum total time in seconds to wait before giving up.
        base_factor: The base duration (in seconds) for the backoff calculation.
        jitter: If True, adds a random jitter to the wait time to prevent synchronized retries.

    Returns:
        An agent hook that implements the backoff logic.
    """
    import litellm.exceptions

    return backoff_on_error(
        (litellm.exceptions.RateLimitError, litellm.exceptions.APIError),
        max_time=max_time,
        max_tries=max_tries,
        base_factor=base_factor,
        jitter=jitter,
    )
```


</Accordion>

retry\_with\_feedback
---------------------

```python
retry_with_feedback(
    event_type: type[AgentEvent]
    | Callable[[AgentEvent], bool],
    feedback: str,
) -> Hook
```

Create a hook that provides feedback when the specified event occurs.

**Parameters:**

* **`event_type`**
  (`type[AgentEvent] | Callable[[AgentEvent], bool]`)
  –The type of event to listen for, or a callable that returns True if feedback should be provided.
* **`feedback`**
  (`str`)
  –The feedback message to provide when the event occurs.

**Returns:**

* `Hook`
  –A hook that provides feedback when the event occurs.

<Accordion title="Source code in dreadnode/agent/hooks/base.py" icon="code">
```python
def retry_with_feedback(
    event_type: "type[AgentEvent] | t.Callable[[AgentEvent], bool]", feedback: str
) -> "Hook":
    """
    Create a hook that provides feedback when the specified event occurs.

    Args:
        event_type: The type of event to listen for, or a callable that returns True if feedback should be provided.
        feedback: The feedback message to provide when the event occurs.

    Returns:
        A hook that provides feedback when the event occurs.
    """

    async def retry_with_feedback(event: "AgentEvent") -> "Reaction | None":
        if isinstance(event_type, type) and not isinstance(event, event_type):
            return None

        if inspect.isfunction(event_type) and not event_type(event):
            return None

        return RetryWithFeedback(feedback=feedback)

    return retry_with_feedback
```


</Accordion>

summarize\_when\_long
---------------------

```python
summarize_when_long(
    model: str | Generator | None = None,
    max_tokens: int = 100000,
    min_messages_to_keep: int = 5,
) -> Hook
```

Creates a hook to manage the agent's context window by summarizing the conversation history.

This hook operates in two ways:
1. **Proactively (on `StepStart`)**: Before each step, it checks the `input_tokens` from the
last `GenerationEnd` event. If it exceeds `max_tokens`, it summarizes older messages.
2. **Reactively (on `AgentError`)**: If the agent fails with a context length error,
it summarizes the history and retries the step.

**Parameters:**

* **`model`**
  (`str | Generator | None`, default:
  `None`
  )
  –The model identifier or generator to use for summarization, otherwise it will use the agent's model.
* **`max_tokens`**
  (`int`, default:
  `100000`
  )
  –The maximum number of tokens allowed in the context window before summarization is triggered
  (default is None, meaning no proactive summarization).
* **`min_messages_to_keep`**
  (`int`, default:
  `5`
  )
  –The minimum number of messages to retain after summarization (default is 5).

<Accordion title="Source code in dreadnode/agent/hooks/summarize.py" icon="code">
```python
@component
def summarize_when_long(
    model: str | rg.Generator | None = None,
    max_tokens: int = 100_000,
    min_messages_to_keep: int = 5,
) -> "Hook":
    """
    Creates a hook to manage the agent's context window by summarizing the conversation history.

    This hook operates in two ways:
    1.  **Proactively (on `StepStart`)**: Before each step, it checks the `input_tokens` from the
        last `GenerationEnd` event. If it exceeds `max_tokens`, it summarizes older messages.
    2.  **Reactively (on `AgentError`)**: If the agent fails with a context length error,
        it summarizes the history and retries the step.

    Args:
        model: The model identifier or generator to use for summarization, otherwise it will use the agent's model.
        max_tokens: The maximum number of tokens allowed in the context window before summarization is triggered
            (default is None, meaning no proactive summarization).
        min_messages_to_keep: The minimum number of messages to retain after summarization (default is 5).
    """

    if min_messages_to_keep < 2:
        raise ValueError("min_messages_to_keep must be at least 2.")

    @component
    async def summarize_when_long(  # noqa: PLR0912
        event: AgentEvent,
        *,
        model: str | rg.Generator | None = Config(  # noqa: B008
            model,
            help="Model to use for summarization - fallback to the agent model",
            expose_as=str | None,
        ),
        max_tokens: int | None = Config(
            max_tokens,
            help="Maximum number of tokens observed before summarization is triggered",
        ),
        min_messages_to_keep: int = Config(
            5, help="Minimum number of messages to retain after summarization"
        ),
    ) -> Reaction | None:
        should_summarize = False

        # Proactive check using the last known token count
        if max_tokens is not None and isinstance(event, StepStart):
            last_token_count = _get_last_input_tokens(event)
            if last_token_count > 0 and last_token_count > max_tokens:
                should_summarize = True

        # Reactive check based on the error message
        elif isinstance(event, AgentError):
            if _is_context_length_error(event.error):
                should_summarize = True

        if not should_summarize:
            return None

        summarizer_model = model or event.agent.model
        if summarizer_model is None:
            return None

        messages = list(event.messages)

        # Check if we have enough messages to summarize
        if len(messages) <= min_messages_to_keep:
            return None

        # Exclude the system message from the summarization process.
        system_message: rg.Message | None = (
            messages.pop(0) if messages and messages[0].role == "system" else None
        )

        # Find the best point to summarize by walking the message list once.
        # A boundary is valid after a simple assistant message or a finished tool block.
        best_summarize_boundary = 0
        for i, message in enumerate(messages):
            # If the remaining messages are less than or equal to our minimum, we can't slice any further.
            if len(messages) - i <= min_messages_to_keep:
                break

            # Condition 1: The message is an assistant response without tool calls.
            is_simple_assistant = message.role == "assistant" and not getattr(
                message, "tool_calls", None
            )

            # Condition 2: The message is the last in a block of tool responses.
            is_last_tool_in_block = message.role == "tool" and (
                i + 1 == len(messages) or messages[i + 1].role != "tool"
            )

            if is_simple_assistant or is_last_tool_in_block:
                best_summarize_boundary = i + 1

        if best_summarize_boundary == 0:
            return None  # No valid slice point was found.

        messages_to_summarize = messages[:best_summarize_boundary]
        messages_to_keep = messages[best_summarize_boundary:]

        if not messages_to_summarize:
            return None

        # Generate the summary and rebuild the messages
        summary = await summarize_conversation.bind(summarizer_model)(
            "\n".join(str(msg) for msg in messages_to_summarize)
        )
        summary_content = (
            f"<conversation-summary messages={len(messages_to_summarize)}>\n"
            f"{summary.summary}\n"
            "</conversation-summary>"
        )

        new_messages: list[rg.Message] = []
        if system_message:
            new_messages.append(system_message)
        new_messages.append(rg.Message("user", summary_content, metadata={"summary": True}))
        new_messages.extend(messages_to_keep)

        return (
            Continue(messages=new_messages)
            if isinstance(event, StepStart)
            else Retry(messages=new_messages)
        )

    return summarize_when_long
```


</Accordion>

tool\_metrics
-------------

```python
tool_metrics(*, detailed: bool = False) -> Hook
```

Creates an agent hook to log metrics about tool usage, execution time, and success rates.

**Parameters:**

* **`detailed`**
  (`bool`, default:
  `False`
  )
  –If True, logs metrics for each specific tool in addition to general stats.
  If False, only logs aggregate statistics across all tools.

**Returns:**

* `Hook`
  –An async hook function that can be registered with an agent.

<Accordion title="Source code in dreadnode/agent/hooks/metrics.py" icon="code">
```python
def tool_metrics(*, detailed: bool = False) -> Hook:
    """
    Creates an agent hook to log metrics about tool usage, execution time, and success rates.

    Args:
        detailed: If True, logs metrics for each specific tool in addition to general stats.
                  If False, only logs aggregate statistics across all tools.

    Returns:
        An async hook function that can be registered with an agent.
    """
    _start_times: dict[str, datetime] = {}

    @component
    async def tool_metrics(
        event: AgentEvent,
        *,
        detailed: bool = Config(
            default=detailed,
            help="If True, logs metrics for each specific tool in addition to general stats.",
        ),
    ) -> None:
        """The actual hook implementation that processes agent events."""
        from dreadnode import log_metric

        if isinstance(event, ToolStart):
            log_metric("tool/total_count", 1, step=event.step, mode="count")
            _start_times[event.tool_call.id] = event.timestamp

            if detailed:
                tool_name = event.tool_call.name
                log_metric(f"tool/count.{tool_name}", 1, step=event.step, mode="count")

        elif isinstance(event, ToolEnd):
            tool_name = event.tool_call.name
            start_time = _start_times.pop(event.tool_call.id, event.timestamp)
            duration_seconds = (event.timestamp - start_time).total_seconds()
            errored = "error" in event.message.metadata

            log_metric("tool/total_time", duration_seconds, step=event.step, mode="sum")
            log_metric("tool/success_rate", 0 if errored else 1, step=event.step, mode="avg")

            if errored:
                log_metric("tool/failed_count", 1, step=event.step, mode="count")

            if detailed:
                log_metric(
                    f"tool/time.{tool_name}",
                    duration_seconds,
                    step=event.step,
                    mode="sum",
                )
                log_metric(
                    f"tool/avg_time.{tool_name}",
                    duration_seconds,
                    step=event.step,
                    mode="avg",
                )
                log_metric(
                    f"tool/success_rate.{tool_name}",
                    0 if errored else 1,
                    step=event.step,
                    mode="avg",
                )

                if errored:
                    log_metric(
                        f"tool/failed_count.{tool_name}",
                        1,
                        step=event.step,
                        mode="count",
                    )

    return tool_metrics
```


</Accordion>
AgentEvent
----------

```python
AgentEvent(
    session_id: ULID,
    agent: Agent,
    thread: Thread,
    messages: list[Message],
    events: list[AgentEvent],
    *,
    timestamp: datetime = (
        lambda: datetime.now(timezone.utc)
    )(),
)
```

### agent

```python
agent: Agent = field(repr=False)
```

The agent associated with this event.

### estimated\_cost

```python
estimated_cost: float | None
```

Estimates the cost of the agent run based on total token usage and model pricing.

### events

```python
events: list[AgentEvent] = field(repr=False)
```

Current events for this run session.

### last\_usage

```python
last_usage: Usage | None
```

Returns the usage from the last generation event, if available.

### messages

```python
messages: list[Message] = field(repr=False)
```

Current messages for this run session.

### session\_id

```python
session_id: ULID = field(repr=False)
```

The unique identifier for the agent run session.

### thread

```python
thread: Thread = field(repr=False)
```

The thread associated with this event.

### timestamp

```python
timestamp: datetime = field(
    default_factory=lambda: now(utc),
    kw_only=True,
    repr=False,
)
```

The timestamp of when the event occurred (UTC).

### total\_usage

```python
total_usage: Usage
```

Aggregates the usage from all events in the run session.

### format\_as\_panel

```python
format_as_panel(*, truncate: bool = False) -> Panel
```

Renders the event as a rich Panel. Can be customized by higher-level systems.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def format_as_panel(self, *, truncate: bool = False) -> Panel:  # noqa: ARG002
    """Renders the event as a rich Panel. Can be customized by higher-level systems."""
    return Panel(
        Text(repr(self)),
        title=f"[dim]{self.__class__.__name__}[/dim]",
        border_style="dim",
    )
```


</Accordion>

### get\_events\_by\_type

```python
get_events_by_type(
    event_type: type[AgentEventT],
) -> list[AgentEventT]
```

Returns all events of the specified type from the thread's events.

**Parameters:**

* **`event_type`**
  (`type[AgentEventT]`)
  –The type of event to search for.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def get_events_by_type(self, event_type: type[AgentEventT]) -> list[AgentEventT]:
    """
    Returns all events of the specified type from the thread's events.

    Args:
        event_type: The type of event to search for.
    """
    return [event for event in self.events if isinstance(event, event_type)]
```


</Accordion>

### get\_latest\_event\_by\_type

```python
get_latest_event_by_type(
    event_type: type[AgentEventT],
) -> AgentEventT | None
```

Returns the latest event of the specified type from the thread's events.

**Parameters:**

* **`event_type`**
  (`type[AgentEventT]`)
  –The type of event to search for.

<Accordion title="Source code in dreadnode/agent/events.py" icon="code">
```python
def get_latest_event_by_type(self, event_type: type[AgentEventT]) -> AgentEventT | None:
    """
    Returns the latest event of the specified type from the thread's events.

    Args:
        event_type: The type of event to search for.
    """
    for event in reversed(self.events):
        if isinstance(event, event_type):
            return event
    return None
```


</Accordion>

AgentEventInStep
----------------

```python
AgentEventInStep(
    session_id: ULID,
    agent: Agent,
    thread: Thread,
    messages: list[Message],
    events: list[AgentEvent],
    *,
    timestamp: datetime = (
        lambda: datetime.now(timezone.utc)
    )(),
)
```

### step

```python
step: int
```

Returns the current step number.


StopCondition
-------------

```python
StopCondition(
    func: Callable[[Sequence[AgentEvent]], bool],
    name: str | None = None,
)
```

A condition that determines when an agent's run should stop, defined by a callable.
Conditions can be combined using & (AND) and | (OR).

Initializes the StopCondition.

**Parameters:**

* **`func`**
  (`Callable[[Sequence[AgentEvent]], bool]`)
  –A callable that takes a sequence of events and returns True if the run should stop.
* **`name`**
  (`str | None`, default:
  `None`
  )
  –An optional name for the condition for representation.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __init__(self, func: t.Callable[[Sequence[AgentEvent]], bool], name: str | None = None):
    """
    Initializes the StopCondition.

    Args:
        func: A callable that takes a sequence of events and returns True if the run should stop.
        name: An optional name for the condition for representation.
    """

    if name is None:
        unwrapped = inspect.unwrap(func)
        name = get_callable_name(unwrapped, short=True)

    self.func = func
    """The function that defines the stop condition."""
    self.name = name
    """A human-readable name for the condition."""
```


</Accordion>

### func

```python
func = func
```

The function that defines the stop condition.

### name

```python
name = name
```

A human-readable name for the condition.

### \_\_and\_\_

```python
__and__(other: StopCondition) -> StopCondition
```

Combines this condition with another using AND logic.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __and__(self, other: "StopCondition") -> "StopCondition":
    """Combines this condition with another using AND logic."""
    return and_(self, other)
```


</Accordion>

### \_\_or\_\_

```python
__or__(other: StopCondition) -> StopCondition
```

Combines this condition with another using OR logic.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def __or__(self, other: "StopCondition") -> "StopCondition":
    """Combines this condition with another using OR logic."""
    return or_(self, other)
```


</Accordion>

and\_
-----

```python
and_(
    condition: StopCondition,
    other: StopCondition,
    *,
    name: str | None = None,
) -> StopCondition
```

Perform a logical AND with two stop conditions.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def and_(
    condition: StopCondition, other: StopCondition, *, name: str | None = None
) -> StopCondition:
    """Perform a logical AND with two stop conditions."""

    def stop(events: Sequence[AgentEvent]) -> bool:
        return condition(events) and other(events)

    return StopCondition(stop, name=name or f"({condition.name}_and_{other.name})")
```


</Accordion>

elapsed\_time
-------------

```python
elapsed_time(max_seconds: int) -> StopCondition
```

Stop if the total execution time exceeds a given duration.

**Parameters:**

* **`max_seconds`**
  (`int`)
  –The maximum number of seconds the agent is allowed to run.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def elapsed_time(max_seconds: int) -> StopCondition:
    """
    Stop if the total execution time exceeds a given duration.

    Args:
        max_seconds: The maximum number of seconds the agent is allowed to run.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        if len(events) < 2:
            return False

        first_event = events[0]
        last_event = events[-1]

        delta = last_event.timestamp - first_event.timestamp
        return delta.total_seconds() > max_seconds

    return StopCondition(stop, name="stop_on_elapsed_time")
```


</Accordion>

estimated\_cost
---------------

```python
estimated_cost(limit: float) -> StopCondition
```

Stop if the estimated cost of LLM generations exceeds a limit.

**Parameters:**

* **`limit`**
  (`float`)
  –The maximum cost allowed (USD).

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def estimated_cost(limit: float) -> StopCondition:
    """
    Stop if the estimated cost of LLM generations exceeds a limit.

    Args:
        limit: The maximum cost allowed (USD).
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        last_event = next((e for e in reversed(events)), None)
        if not last_event:
            return False
        estimated_cost = last_event.estimated_cost
        return estimated_cost > limit if estimated_cost else False

    return StopCondition(stop, name="stop_on_estimated_cost")
```


</Accordion>

generation\_count
-----------------

```python
generation_count(max_generations: int) -> StopCondition
```

Stop after a maximum number of LLM generations (inference calls).

This is slightly more robust than using `max_steps` as
retry calls to the LLM will also count towards this limit.

**Parameters:**

* **`max_generations`**
  (`int`)
  –The maximum number of LLM generations to allow.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def generation_count(max_generations: int) -> StopCondition:
    """
    Stop after a maximum number of LLM generations (inference calls).

    This is slightly more robust than using `max_steps` as
    retry calls to the LLM will also count towards this limit.

    Args:
        max_generations: The maximum number of LLM generations to allow.
    """

    @component
    def stop(
        events: Sequence[AgentEvent], *, max_generations: int = Config(max_generations)
    ) -> bool:
        generation_count = sum(1 for event in events if isinstance(event, GenerationEnd))
        return generation_count >= max_generations

    return StopCondition(stop, name="stop_on_generation_count")
```


</Accordion>

never
-----

```python
never() -> StopCondition
```

A condition that never stops the agent.

This is generally useful for triggering stalling
conditions when an agent does not issue any tool
calls, and a hook reaction will be used.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def never() -> StopCondition:
    """
    A condition that never stops the agent.

    This is generally useful for triggering stalling
    conditions when an agent does not issue any tool
    calls, and a hook reaction will be used.
    """

    def stop(_: Sequence[AgentEvent]) -> bool:
        return False

    return StopCondition(stop, name="stop_never")
```


</Accordion>

no\_new\_tool\_used
-------------------

```python
no_new_tool_used(for_steps: int) -> StopCondition
```

Stop if the agent goes for a number of steps without using a new tool.

**Parameters:**

* **`for_steps`**
  (`int`)
  –The number of consecutive steps without a new tool use
  before the agent should stop.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def no_new_tool_used(for_steps: int) -> StopCondition:
    """
    Stop if the agent goes for a number of steps without using a new tool.

    Args:
        for_steps: The number of consecutive steps without a new tool use
            before the agent should stop.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        step_starts = [e for e in events if isinstance(e, StepStart)]
        if len(step_starts) < for_steps:
            return False

        # Get events from the last `for_steps` steps
        relevant_events = events[events.index(step_starts[-for_steps]) :]

        used_tools_in_period = {e.tool_call.name for e in relevant_events if isinstance(e, ToolEnd)}

        # Find tools used before this period
        prior_events = events[: events.index(step_starts[-for_steps])]
        prior_tools = {e.tool_call.name for e in prior_events if isinstance(e, ToolEnd)}

        # If any tool used in the current period is new, don't stop
        return used_tools_in_period - prior_tools != set()

    return StopCondition(stop, name="stop_on_no_new_tool")
```


</Accordion>

or\_
----

```python
or_(
    condition: StopCondition,
    other: StopCondition,
    *,
    name: str | None = None,
) -> StopCondition
```

Perform a logical OR with two stop conditions.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def or_(
    condition: StopCondition, other: StopCondition, *, name: str | None = None
) -> StopCondition:
    """Perform a logical OR with two stop conditions."""

    def stop(events: Sequence[AgentEvent]) -> bool:
        return condition(events) or other(events)

    return StopCondition(stop, name=name or f"({condition.name}_or_{other.name})")
```


</Accordion>

output
------

```python
output(
    pattern: str | Pattern[str],
    *,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition
```

Stop if a specific string or pattern is mentioned in the last generated message.

**Parameters:**

* **`pattern`**
  (`str | Pattern[str]`)
  –The string or compiled regex pattern to search for.
* **`case_sensitive`**
  (`bool`, default:
  `False`
  )
  –If True, the match is case-sensitive. Defaults to False.
* **`exact`**
  (`bool`, default:
  `False`
  )
  –If True, performs an exact string match instead of containment. Defaults to False.
* **`regex`**
  (`bool`, default:
  `False`
  )
  –If True, treats the `pattern` string as a regular expression. Defaults to False.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def output(
    pattern: str | re.Pattern[str],
    *,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition:
    """
    Stop if a specific string or pattern is mentioned in the last generated message.

    Args:
        pattern: The string or compiled regex pattern to search for.
        case_sensitive: If True, the match is case-sensitive. Defaults to False.
        exact: If True, performs an exact string match instead of containment. Defaults to False.
        regex: If True, treats the `pattern` string as a regular expression. Defaults to False.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        if not events:
            return False

        last_generation = next((e for e in reversed(events) if isinstance(e, GenerationEnd)), None)
        if not last_generation:
            return False

        text = last_generation.message.content
        found = False

        if isinstance(pattern, re.Pattern) or regex:
            compiled = pattern
            if isinstance(pattern, str):
                flags = 0 if case_sensitive else re.IGNORECASE
                compiled = re.compile(pattern, flags)

            if isinstance(compiled, re.Pattern):  # Make type checker happy
                found = bool(compiled.search(text))
        elif exact:
            found = text == pattern if case_sensitive else text.lower() == str(pattern).lower()
        else:  # Default to substring containment
            search_text = text if case_sensitive else text.lower()
            search_pattern = str(pattern) if case_sensitive else str(pattern).lower()
            found = search_pattern in search_text

        return found

    return StopCondition(stop, name="stop_on_output")
```


</Accordion>

token\_usage
------------

```python
token_usage(
    limit: int,
    *,
    mode: Literal["total", "in", "out"] = "total",
) -> StopCondition
```

Stop if the token usage exceeds a specified limit.

**Parameters:**

* **`limit`**
  (`int`)
  –The maximum number of tokens allowed.
* **`mode`**
  (`Literal['total', 'in', 'out']`, default:
  `'total'`
  )
  –Which token count to consider:
  - "total": Total tokens (default)
  - "in": Input tokens only
  - "out": Output tokens only

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def token_usage(limit: int, *, mode: t.Literal["total", "in", "out"] = "total") -> StopCondition:
    """
    Stop if the token usage exceeds a specified limit.

    Args:
        limit: The maximum number of tokens allowed.
        mode: Which token count to consider:
            - "total": Total tokens (default)
            - "in": Input tokens only
            - "out": Output tokens only
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        last_event = next((e for e in reversed(events)), None)
        if not last_event:
            return False

        usage = last_event.total_usage
        token_count = (
            usage.total_tokens
            if mode == "total"
            else (usage.input_tokens if mode == "in" else usage.output_tokens)
        )

        return token_count > limit

    return StopCondition(stop, name="stop_on_token_usage")
```


</Accordion>

tool\_error
-----------

```python
tool_error(tool_name: str | None = None) -> StopCondition
```

Stop if any tool call results in an gracefully handled error.

**Parameters:**

* **`tool_name`**
  (`str | None`, default:
  `None`
  )
  –If specified, only considers errors from this tool.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_error(tool_name: str | None = None) -> StopCondition:
    """
    Stop if any tool call results in an gracefully handled error.

    Args:
        tool_name: If specified, only considers errors from this tool.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        for event in reversed(events):
            if isinstance(event, ToolEnd):
                if tool_name and event.tool_call.name != tool_name:
                    continue

                if "error" in event.message.metadata:
                    return True

        return False

    return StopCondition(stop, name="stop_on_tool_error")
```


</Accordion>

tool\_output
------------

```python
tool_output(
    pattern: str | Pattern[str],
    *,
    tool_name: str | None = None,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition
```

Stop if a specific string or pattern is found in the output of a tool call.

**Parameters:**

* **`pattern`**
  (`str | Pattern[str]`)
  –The string or compiled regex pattern to search for.
* **`tool_name`**
  (`str | None`, default:
  `None`
  )
  –If specified, only considers outputs from this tool.
* **`case_sensitive`**
  (`bool`, default:
  `False`
  )
  –If True, the match is case-sensitive. Defaults to False.
* **`exact`**
  (`bool`, default:
  `False`
  )
  –If True, performs an exact string match instead of containment. Defaults to False.
* **`regex`**
  (`bool`, default:
  `False`
  )
  –If True, treats the `pattern` string as a regular expression. Defaults to False.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_output(
    pattern: str | re.Pattern[str],
    *,
    tool_name: str | None = None,
    case_sensitive: bool = False,
    exact: bool = False,
    regex: bool = False,
) -> StopCondition:
    """
    Stop if a specific string or pattern is found in the output of a tool call.

    Args:
        pattern: The string or compiled regex pattern to search for.
        tool_name: If specified, only considers outputs from this tool.
        case_sensitive: If True, the match is case-sensitive. Defaults to False.
        exact: If True, performs an exact string match instead of containment. Defaults to False.
        regex: If True, treats the `pattern` string as a regular expression. Defaults to False.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        for event in reversed(events):
            if isinstance(event, ToolEnd):
                if tool_name and event.tool_call.name != tool_name:
                    continue

                output = event.message.content
                if output is None:
                    continue

                text = str(output)
                found = False

                if isinstance(pattern, re.Pattern) or regex:
                    compiled = pattern
                    if isinstance(pattern, str):
                        flags = 0 if case_sensitive else re.IGNORECASE
                        compiled = re.compile(pattern, flags)

                    if isinstance(compiled, re.Pattern):  # Make type checker happy
                        found = bool(compiled.search(text))
                elif exact:
                    found = (
                        text == pattern if case_sensitive else text.lower() == str(pattern).lower()
                    )
                else:  # Default to substring containment
                    search_text = text if case_sensitive else text.lower()
                    search_pattern = str(pattern) if case_sensitive else str(pattern).lower()
                    found = search_pattern in search_text

                if found:
                    return True

        return False

    return StopCondition(stop, name="stop_on_tool_output")
```


</Accordion>

tool\_use
---------

```python
tool_use(
    tool_name: str, *, count: int = 1
) -> StopCondition
```

Stop after a specific tool has been successfully used.

**Parameters:**

* **`tool_name`**
  (`str`)
  –The name of the tool to monitor.
* **`count`**
  (`int`, default:
  `1`
  )
  –The number of times the tool must be used to trigger stopping. Defaults to 1.

<Accordion title="Source code in dreadnode/agent/stop.py" icon="code">
```python
def tool_use(tool_name: str, *, count: int = 1) -> StopCondition:
    """
    Stop after a specific tool has been successfully used.

    Args:
        tool_name: The name of the tool to monitor.
        count: The number of times the tool must be used to trigger stopping. Defaults to 1.
    """

    def stop(events: Sequence[AgentEvent]) -> bool:
        tool_count = sum(
            1 for e in events if isinstance(e, ToolEnd) and e.tool_call.name == tool_name
        )
        return tool_count >= count

    return StopCondition(stop, name="stop_on_tool_use")
```


</Accordion>
Thread
------

### events

```python
events: list[AgentEvent] = Field(default_factory=list)
```

All events that have occurred during the use of this thread.

### last\_usage

```python
last_usage: Usage | None
```

Returns the usage from the last generation event, if available.

### messages

```python
messages: list[Message] = Field(default_factory=list)
```

The current messages for this thread.

### total\_usage

```python
total_usage: Usage
```

Aggregates the usage from all events in the thread.