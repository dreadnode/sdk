---
title: "Agents"
description: "Autonomous LLM-driven systems with tools."
public: true
---

An **`Agent`** uses a Large Language Model (LLM) to orchestrate a cycle of reasoning and action. At the core agents run a "think-act-observe" loop: it **thinks** about what to do, **acts** by using tools, and **observes** the results to inform its next thought.

## Agent Basics

The `Agent` class is the heart of the system. You'll find it doesn't contain specific logic, or require overloading to change, but rather orchestrates the components you provide. When you create an **`Agent`**, you define its core identity and capabilities.

<CodeGroup>
```python Simple Config
import dreadnode as dn

agent = dn.Agent(
    name="File Explorer",
    model="gpt-4-turbo",
    tools=[
        dn.agent.tools.fs.Filesystem(variant="read")
    ],
)

# run until done
result = await agent.run("Summarize the README.")

# stream events
async with agent.stream("Summarize the README.") as events:
    async for event in events:
        print(event)

# print to console
await agent.console("Summarize the README.")
```

```python Full Config
import dreadnode as dn

agent = dn.Agent(
    name="File Explorer",
    model="gpt-4-turbo",
    tools=[
        dn.agent.tools.fs.Filesystem(variant="read")
    ],
    description="Agent with read-only filesystem capabilities.",
    instructions="You are an expert at exploring local filesystems. Be concise.",
    max_steps=5,
    tags=["fs"],
    hooks=[dn.agent.hooks.summarize_when_long()],
    scorers=[dn.scorers.contains("summary")],
    stop_conditions=[dn.agent.stop.estimated_cost(5)],
)

# run until done
result = await agent.run("Summarize the README.")

# stream events
async with agent.stream("Summarize the README.") as events:
    async for event in events:
        print(event)

# print to console
await agent.console("Summarize the README.")
```
</CodeGroup>

You have 3 primary methods for executing an agent in code:

- `run()`: Use this when you just need a final answer. It executes the entire think-act-observe loop until completion and returns a single `AgentResult` object.
- `stream()`: Use this when you need to see the process unfold in real-time. It's an `async` context manager that yields `AgentEvent` objects as they happen, which is perfect for building responsive UIs or detailed logging systems.
- `console()`: Use this for a quick, human-friendly view of the entire run. It streams the agent's messages and events directly to your console with rich formatting.

## Agents in the CLI

In addition to running agents programmatically, Dreadnode includes a powerful command-line interface (CLI) that is essential for testing, debugging, and interacting with your agents. All CLI functionality is available under the `dn agent` command.

### Discovering and Listing Agents

The CLI will automatically search for agents in common files like `agent.py` and `main.py`.

```bash
$ dn agent ls

Agents in agent.py:

╭───────┬───────────────────┬─────────────┬──────────────────────────────╮
│ Name  │ Description       │ Model       │ Tools                        │
├───────┼───────────────────┼─────────────┼──────────────────────────────┤
│ basic │ A basic agent ... │ gpt-4o-mini │ Filesystem, finish_task, ... │
╰───────┴───────────────────┴─────────────┴──────────────────────────────╯
```

To see a more detailed view, including all hooks, stop conditions, and other configurations, use the `--verbose` or `-v` flag.

```bash
$ dn agent ls -v

Agents in agent.py:

╭─ basic ───────────────────────────────────────────────────────────────────╮
│                ╷                                                          │
│    Description │ A basic agent that can handle simple tasks.              │
│          Model │ gpt-4o-mini                                              │
│          Tools │ Filesystem, finish_task, give_up_on_task, update_todo    │
│          Hooks │ retry_with_feedback, summarize_when_long                 │
│          Stops │ stop_on_generation_count, stop_never                     │
│                ╵                                                          │
╰───────────────────────────────────────────────────────────────────────────╯
```

### Running and Configuring Agents

The `run` command takes the agent's name and the user input as arguments. The agent's name can be specified as just the name (`basic`), a file (`agent.py`), or a combination (`agent.py:basic`).

The most powerful feature of the CLI is its ability to automatically generate command-line arguments from your agent's configuration. To see all available options for a specific agent, use the `help` command.

```bash
$ dn agent run basic help

Usage: basic [ARGS] [OPTIONS]

Run the 'basic' agent.

╭─ Parameters ────────────────────────────────────────────────────────────────╮
│ *  INPUT --input  Input to the agent [required]                             │
╰─────────────────────────────────────────────────────────────────────────────╯
╭─ Agent Config ──────────────────────────────────────────────────────────────╮
│ --tools.filesystem.path   Base path to work from. [default: /path/to/sdk]   │
│ --model                   Inference model... [default: gpt-4o-mini]         │
│ --max-steps               The maximum number of steps... [default: 10]      │
│ ...                                                                         │
╰─────────────────────────────────────────────────────────────────────────────╯
```

You can then use these generated flags to override any part of the agent's configuration for that specific run.

```bash
# Run the agent with a standard prompt
$ dn agent run basic "Summarize the README.md file"

# Override the model and the filesystem path for this run
$ dn agent run basic "Summarize the file in /tmp" \
    --model "gpt-4-turbo" \
    --tools.filesystem.path "/tmp"
```

<Tip>
This automatic configuration exposure works for any Pydantic `Config` fields on your `Agent` class itself, or on any `Toolset` or `Hook` that it uses. This is a powerful way to make your custom components easily configurable from the command line with no extra work.
</Tip>

## Results

When you `await agent.run()`, it returns an `AgentResult` object that serves as a complete summary of the execution. This is your primary tool for post-run analysis, evaluation, and logging.

Let's look at what you can do with it:

```python
import dreadnode as dn

agent = dn.Agent(...)
result = await agent.run("Solve a complex problem.")

# Check the final status
if result.failed:
    print(f"Agent failed with error: {result.error}")
else:
    print("Agent finished successfully!")
    # The final message from the agent is always the last one in the list
    print(f"Final Message: {result.messages[-1].content}")


# Get key performance metrics
print(f"Execution took {result.steps} steps.")
print(f"Token Usage: {result.usage.total_tokens} total tokens.")

# The result also contains a snapshot of the thread for deeper analysis
print(f"The run generated {len(result.thread.events)} events in total.")
```

## Lifecycle

Every agent run follows a predictable sequence of events. Understanding this lifecycle is the key to knowing *when* and *how* you can influence its behavior. For every **step** (up to `max_steps`), the agent proceeds as follows:

```
  [ Start Run ]
        ↓
┌──── Step 1 ───┐
│       ↓       │
│   [ Think ]   │  →  GenerationEnd Event
│       ↓       │
│    [ Act ]    │  →  ToolStart / ToolEnd Events
│       ↓       │
└───( Stop? )───┘
        ↓
  [  End Run  ]
```

## Tools

**`Tools`** are Python functions or class methods that you make available to the agent. They

<CodeGroup>
```python @tool (for stateless functions)
import dreadnode as dn

@dn.tool
def get_stock_price(symbol: str) -> float:
    """Gets the current price of a stock symbol."""
    # ... logic to call a financial API ...
    return 150.75
```

```python Toolset (for stateful or grouped tools)
import dreadnode as dn

class DatabaseConnector(dn.Toolset):
    """Handles queries against the company database."""
    connection_string: str

    @dn.tool_method
    def query(self, sql: str) -> list[dict]:
        """Executes a SQL query and returns the results."""
        # ... logic to connect and run query ...
        return [{"id": 1, "name": "Test Co."}]
```
</CodeGroup>

<Tip>
Use the `@tool` decorator for simple, self-contained functions. You'll find a **`Toolset`** is better when you need to group related tools (like `db.query`, `db.insert`) or manage shared state (like a database connection).
</Tip>

## Hooks

A **`Hook`** is a function that runs when a specific `AgentEvent` occurs, allowing you to observe and influence the agent's behavior without modifying its core code.

The most important events you'll encounter are:

- `AgentStart`: The very beginning of a run() or stream() call.
- `StepStart`: The start of a new "think-act" cycle.
- `GenerationEnd`: The think phase is complete. The LLM has returned a message, which may include requests to call tools.
- `ToolStart` / `ToolEnd`: The act phase. A specific tool is called and returns its result.
- `AgentEnd`: The run is finished.

### Observational Hooks

A hook that returns `None` is purely for observation. This is the most common pattern, perfect for logging, metrics, or auditing.

```python
import dreadnode as dn
from dreadnode.agent.events import ToolStart

async def log_tool_usage(event: ToolStart):
    print(f"AUDIT: Agent is calling '{event.tool_call.name}' with ID '{event.tool_call.id}'")

agent = dn.Agent(..., hooks=[log_tool_usage])
```

### Interventional Hooks

To change the agent's flow, your hook must return a **`Reaction`**. Reactions are special exceptions that signal a desired change. The most common way to do this is with a built-in hook helper.

```python
from dreadnode.agent.events import AgentStalled
from dreadnode.agent.hooks import retry_with_feedback

# This hook will react to the AgentStalled event by injecting
# a new message and forcing the agent to retry the step.
unstall_hook = retry_with_feedback(
    event_type=AgentStalled,
    feedback="You seem stuck. You must either use a tool or use the 'finish_task' tool."
)

agent = dn.Agent(..., hooks=[unstall_hook])
```

### Event History in Hooks

A hook isn't limited to the single event that triggered it. The `event` object passed to your hook function contains the entire history of events for the run up to that point (`event.events`). This allows you to create sophisticated logic based on the agent's past behavior.

You can query this history using helper methods like `get_events_by_type()` and `get_latest_event_by_type()`.

**Example: Detecting a Stuck Agent**

Let's write a hook that prevents an agent from getting stuck in a loop, calling the same tool with the same arguments repeatedly.

```python
import dreadnode as dn
from dreadnode.agent.events import ToolStart
from dreadnode.agent.reactions import Fail

async def detect_loops(event: ToolStart) -> Fail | None:
    # Get all previous tool start events from the history
    previous_starts = event.get_events_by_type(ToolStart)

    # See how many times this exact tool call has happened before
    identical_calls = [
        start for start in previous_starts
        if start.tool_call.name == event.tool_call.name
        and start.tool_call.function.arguments == event.tool_call.function.arguments
    ]

    # If it has happened more than twice, intervene.
    if len(identical_calls) > 2:
        return Fail(f"Agent is stuck in a loop calling {event.tool_call.name}.")

    return None

agent = dn.Agent(..., hooks=[detect_loops])
```

## Stop Conditions

A **`StopCondition`** is a function that inspects the history of events after each step and returns `True` if the agent should stop. This provides a clean, declarative way to define the goal state, or define early stopping criteria. Stop conditions are similar to hooks, but they run only once per step, after the agent has thought and acted.

```python
from dreadnode.agent.stop import stop_on_tool_use, stop_on_text

# Stop when the agent successfully uses the 'finish_task' tool.
stop1 = stop_on_tool_use("finish_task")

# Stop when the agent's final message includes "SUCCESS".
stop2 = stop_on_text("SUCCESS")

# Combine them: stop if EITHER condition is met.
agent = dn.Agent(..., stop_conditions=[stop1 | stop2])
```

<Note>
While a hook can stop a run by returning `Finish()`, `StopConditions` are the preferred method for defining the successful end-state of a task. They check the *state* of the run, whereas hooks *react* to individual events.
</Note>

## Threads

The `Agent` class itself is stateless; it's a reusable orchestrator with a defined set of capabilities. The entire history of an interaction, all `messages` and `events`, is stored in a separate `dreadnode.Thread` object. This separation of the "worker" (the `Agent`) from the "work" (the `Thread`) provides great flexibility for managing conversations.

### The Default Thread

For convenience, every agent you create comes with its own internal thread. When you call `run()` or `stream()` without specifying a thread, the agent uses this internal one to store the conversation history.

```python
import dreadnode as dn

# This agent is created with a default, empty thread.
agent = dn.Agent(...)
print(f"Initial messages: {len(agent.thread.messages)}") # -> Initial messages: 0

# The run populates the agent's internal thread.
await agent.run("First question for the agent.")
print(f"Messages after run: {len(agent.thread.messages)}") # -> Messages after run: 3 (user, assistant, tool)
```

You can reset an agent to its original, clean state at any time by calling `agent.reset()`. This simply replaces its internal thread with a new, empty one.

```python
# Continuing from above...
previous_thread = agent.reset()
print(f"Reset agent messages: {len(agent.thread.messages)}")       # -> Reset agent messages: 0
print(f"Previous thread messages: {len(previous_thread.messages)}") # -> Previous thread messages: 3
```

### Reusing Threads

The real power of this pattern becomes clear when you manage the `Thread` object yourself. Both `run()` and `stream()` accept an optional `thread` argument, allowing you to dictate which conversation history the agent should use.

This unlocks several powerful patterns.

<CodeGroup>
```python Persisting and Resuming
import dreadnode as dn

agent = dn.Agent(...)
conversation_thread = dn.Thread()

# First interaction
await agent.run("What files are in the current directory?", thread=conversation_thread)

# ... sometime later, in a different part of your application ...

# The agent has no memory of the first run, but the thread does.
# We can resume the conversation by passing the same thread back in.
await agent.run("Of those files, which one is the largest?", thread=conversation_thread)
```

```python Collaboration Between Agents
import dreadnode as dn

# A specialist in finding files
file_agent = dn.Agent(
    name="File Specialist",
    instructions="You are an expert at finding files.",
    tools=[...], # Filesystem tools
)

# A specialist in writing code
code_agent = dn.Agent(
    name="Code Writer",
    instructions="You are an expert at writing Python code.",
    tools=[...], # File writing tools
)

# A single thread to orchestrate the work
shared_work_thread = dn.Thread()

# Step 1: The file agent finds the relevant file and adds it to the thread.
await file_agent.run("Find the 'main.py' file.", thread=shared_work_thread)

# Step 2: The code agent picks up the same thread and now has the context.
await code_agent.run(
    "Add a print statement to the file you just found.",
    thread=shared_work_thread
)
```
</CodeGroup>

### The Thread on `AgentResult`

Finally, it's important to understand the relationship between the thread you pass in and the one you get back on the `AgentResult`.

When an agent run completes, the `result` object contains a `thread` attribute. This attribute is a **snapshot of the thread's state at the moment that specific run concluded**. Even if you are managing a long-lived thread object, the `result.thread` gives you the precise, isolated history of what happened during that single execution.

```python
import dreadnode as dn

agent = dn.Agent(...)
my_thread = dn.Thread()

# Run the agent with your thread
result = await agent.run("What is 2+2?", thread=my_thread)

# 'my_thread' and 'result.thread' now hold the same state.
# You can use the result's thread to analyze the run that just happened.
print(f"The run took {result.steps} steps.")
tool_events = result.thread.get_events_by_type(dn.agent.events.ToolEnd)
print(f"It used {len(tool_events)} tools.")
```

## Conceptual Summary

This diagram shows how all the pieces fit together:

```
            ┌──────────────────┐
            │      Thread      │ (Memory: Messages & Events)
            └────────┬─────────┘
                     │
┌────────────────────┼────────────────────┐
│   Agent            │                    │
│ (Orchestrator)     ↓                    │
│                                         │
│    ┌───────────────────────────────┐    │
│    │        Lifecycle Loop         │    │
│    │ (Start → Think → Act → Stop?) │    │
│    └───────────────┬───────────────┘    │
│                    │                    │
│ ┌──────────────────┴──────────────────┐ │
│ │          Your Components            │ │
│ │                                     │ │
│ │ ∙ Tools        (For Acting)         │ │
│ │ ∙ Hooks        (For Reacting)       │ │
│ │ ∙ StopCond     (For Finishing)      │ │
│ └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

## `TaskAgent`

Dreadnode includes the **`TaskAgent`**, a subclass of `Agent` that is pre-configured for goal-oriented tasks. It's a powerful demonstration of how the core components can be assembled into a robust, ready-to-use pattern. It comes with:

1. **Default Tools:** Includes `update_todo` for planning, and `finish_task` or `give_up_on_task` for explicit completion.
2. **Resilient Behavior:** It includes a default hook to prevent it from stalling and a `never` step condition, forcing it to work until it explicitly finishes its task.

The implementation is a great example of building specializations on top of the `Agent` base class:

```python
class TaskAgent(Agent):
    def model_post_init(self, _: t.Any) -> None:
        self.tools.extend([finish_task, give_up_on_task, update_todo])
        self.stop_conditions.append(never())
        self.hooks.insert(0,
            retry_with_feedback(
                event_type=AgentStalled,
                feedback="Continue the task if possible, use the 'finish_task' tool to complete it, or 'give_up_on_task' if it cannot be completed.",
            ),
        )
```

## Advanced Concepts

As you build more complex agents, you'll find these deeper mechanics useful.

### Agent Stalling

An agent is considered "stalled" only under specific circumstances. The `AgentStalled` event will fire if, and only if:
1. The agent produces a response with **no tool calls**.
2. The agent has `StopConditions` defined, and **none of them are met**.

If an agent stops using tools and has no stop conditions, it simply finishes its run successfully. This event is your tool for handling cases where the agent gets "stuck" and doesn't know how to proceed toward its goal.

### Hook Reaction Priority

If multiple hooks react to the same event, only one "winning" reaction is chosen based on this priority:
1.  **`Finish`** reactions always win.
2.  **`Retry`** / **`RetryWithFeedback`** reactions are chosen next.
3.  **`Continue`** reactions are chosen after retries.

The system will log a warning if a hook's reaction was ignored, which is a key signal for debugging.